# 1 Java开发环境与程序入门
## 1.1 Java开发环境
### 1.1.1 Java虚拟机——JVM
- JVM是所有Java程序运行的假象计算机。

### 1.1.2 JDK和JRE
- JDK是Java程序开发工具包，包含JRE和开发人员使用的工具。
- JRE是Java程序的运行环境，包含jvm和运行时所需要的核心类库。
JDK>JRE>JVM

## 1.2 JAVA程序入门
### 1.2.1 Java程序开发三步骤
- 编写(.java)→编译(javac.exe编译)→运行(.class)

### 1.2.2 注释comment
- 单行注释      //
- 多行注释      /* 内容 */
- 文档注释      /** 内容 */
```java
//这是单行注释
/*
这是多行注释
*/
/**
这是文档注释
*/
```

### 1.2.3 关键字keywords
- 关键字：是指在程序中，Java已经定义好的单词，具有特殊含义。如public、class等。

### 1.2.4 标识符
- 程序中我们自己定义的内容。比如类名、方法名、变量名等。
- 命名规则
    - 标识符可以包含26个英文字母（区分大小写）、数字、美元符号$和下划线_；
    - 标识符不能以数字开头；
    - 标识符不能是关键字。
- 命名规范：
    - 类名：大驼峰式，首字母大写，后面每个单词首字母大写。
    - 方法名与变量名：小驼峰式，首字母小写，后面每个单词首字母大写。

# 2 基本数据类型和运算符
## 2.1 数据类型、常量、变量
### 2.1.1 数据类型
- 基本数字类型：整数、浮点、字符、布尔。
- 引用数据类型：类、数组、接口。

### 2.1.2 常量
- 整数常量、小数常量、字符常量、字符串常量、布尔常量、空常量。

### 2.1.3 变量
- 变量在内存中装载数据，用来存取数据。
- 创建：数据类型&ensp;变量名&ensp;=&ensp;数据值；
- 使用注意事项：
    - 变量定义后可以不赋值，使用时再赋值。不赋值不能使用。
    - 变量使用时有作用域的限制
    - 变量不可以重复定义

### 2.1.4 基本类型4类8种

| 数据类型 | 关键字 | 内存占用 |
| --- | --- | --- |
| 短整型 | short | 2 |
| 整型 | int | 4 |
| 长整型 | long | 8 |
| 单精度浮点型 | double | 4 |
| 双精度浮点型 | float | 8 |
| **字节型** | byte | 1 |
| 字符型 | **char** | **2** |
| 布尔型 | boonlean | **1** |

## 2.2 数据类型转换
### 2.2.1 自动转换与强制转换
- 自动转换：将`取值范围小的类型`自动提升为`取值范围大的类型` 。
- 强制转换：将`取值范围大的类型`强制转换成`取值范围小的类型`。（如int i = （short）100）。

- 注意事项
    - 浮点转成整数，直接取消小数点，可能造成数据损失精度。
    - `int` 强制转成`short` 砍掉2个字节，可能造成数据丢失。

## 2.3 运算符
### 2.3.1 算术运算符

| 正号、加 | 连接字符串 | 负号、减 | 乘 | 除 | 取模 | 自增、自减 |
| --- | --- | --- | --- | --- | --- | --- |
| + | + | - | * | / | % | ++、-- |

### 2.3.2 赋值运算符

| 赋值 | 加后赋值 | 减后赋值 | 乘后赋值 | 整除后赋值 | 取模后赋值 |
| --- | --- | --- | --- | --- | --- |
| = | += | -= | *= | /= | %= |

### 2.3.3 比较运算符

| 相等于 | 不等于 | 大于 | 小于 | 小于等于 | 大于等于 |
| --- | --- | --- | --- | --- | --- |
| == | != | > | < | <= | >= |

### 2.3.4 逻辑运算符

| 与 | 或 | 异或 | 非 | 短路与 | 短路或 |
| --- | --- | --- | --- | --- | --- |
| & | \| | ^ | ！ | && | \|\| |
| 全真则真 | 有真则真 | 不同为真 | 取反 | 全真则真 | 有真则真 |

### 2.3.5 位运算符
| 位运算符包括： |                                        |
| -------------- | -------------------------------------- |
| << 左移        | 左移就是把所有位向左移动几位  补0      |
| >> 右移        | 右移就是把所有位向右移动几位  补最高位 |
M << n   |   M << n  = M \* 2的n次方|     
M >>n    |  M >>n  = M /2的n次方|
### 2.3.6 三元运算符
 数据类型 变量名 = 条件表达式？表达式1：表达式2
### 2.3.7 运算符优先级

# 3 程序逻辑控制
## 3.1 流程控制
### 3.1.1 判断语句
- if
- if...else
- if...else&ensp;if...esle

### 3.1.2 选择语句
- switch
```java
switch(表达式) {
  case 常量值1:
    语句体1;
    break;
  case 常量值2:
    语句体2;
    break;
  ...
  default:
    语句体n+1;
    break;
}
```
- case的穿透性
在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束。

### 3.1.3 循环语句
- for
- while
- do...while
- 跳出语句
    - break:终止switch或者循环
    - continue:结束本次循环，继续下一次的循环

# 4 数组
## 4.1 数组的定义与访问
- 数组的概念：存储数据长度固定的容器，其中数据类型要一致。
- 数组的初始化：
    - int[] arr = new int[5];
    - int[] arr = new int[]{1,2,3,4,5};
    - int[] arr = {1,2,,3,4,5}
- 数组的访问：数组名[索引]

## 4.2 数组内存原理
### 4.2.1 内存概述
Java虚拟机的内存划分
- 寄存器：给CPU使用
- 本地方法栈：JVM在使用操作系统功能的时候使用
- 方法区：存储可以运行的class文件。
- 堆内存：存储对象或者数组，new来创建的，都存储在堆内存。
- 栈内存：方法运行时使用的内存，比如main方法运行，进入方法栈中执行。

### 4.2.2 数组在内存中的储存


# 5 方法
## 5.1 方法的定义
### 5.1.1 方法的四种定义形式
- 空参无返回值
- 空参有返回值
- 带参无返回值
- 带参有返回值

### 5.1.2 定义方法的三个明确点
- 明确方法名称
- 明确返回值类型
- 明确参数列表

### 5.1.3 定义方法的注意事项
- 方法不能嵌套定义
- 返回值类型，必须要和`return`语句返回的类型相同，否则编译失败 。
- 同一个逻辑中 , 不能在`return` 语句后面写代码。
- void表示无返回值，可以省略return，也可以单独的书写`return;`，后面不加数据

### 5.1.4 方法重载
- 概念：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。
- 多个方法在同一个类中
- 多个方法具有相同的方法名
- 多个方法的参数不相同，类型不同或者数量不同


# 6 类和对象
## 6.1 面向对象
### 6.1.1 类与对象的关系
- 类：类是对一类事物的描述，是**抽象的**
- 对象：对象是一类事物的实例，是**具体的**。
- 类是对象的模板，对象是类的实体。

### 6.1.2 类与对象的定义
- 类的定义格式
```java
public class 类名{
    //变量
    //方法
}
```
- 对象的使用
```java
类名 对象名 = new 类名；
对象名.成员变量；
对象名.成员方法()；
```

### 6.1.3 成员变量的默认值

|  | 数据类型 | 默认值 |
| --- | --- | --- |
| 基本类型 | 整型 | 0 |
| 基本类型 | 浮点数 | 0.0 |
| 基本类型 | 字符 | '/u000' |
| 基本类型 | 布尔 | false |
| 引用类型 | 数组、类、接口 | null |

## 6.2 封装
### 6.2.1 封装概述
- 概述：封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。
- 原则：将**属性隐藏**起来，若需要访问某个属性，**提供公共方法**对其访问。

### 6.2.2 封装的步骤
1.private关键字修饰成员变量。
2.对需要访问的成员变量，提供对应的一对 `getXxx`方法 、`setXxx` 方法。

### 6.2.3 封装的操作——private关键字
- private的含义
    - private是一个权限修饰符，代表最小权限。
    - 可以修饰成员变量和成员方法。
    - 被private修饰后的成员变量和成员方法，只在本类中才能访问。
- private的使用格式
```java
private 数据类型 变量名 ；
```

### 6.2.4 封装的this关键字
- this代表所在类的当前对象的引用（地址值），即对象自己的引用。

### 6.2.5 封装的构造方法
- 当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。
```java
修饰符 构造方法名(参数列表){
	// 方法体
}
```
- 注意事项
    - 如果你不提供构造方法，系统会给出无参数构造方法。
    - 如果你提供了构造方法，系统将不再提供无参数构造方法。
    - 构造方法是可以重载的，既可以定义参数，也可以不定义参数。

### 6.2.6 标准代码——javaBean
- 要求：
    - 类必须是具体的和公共的
    - 具有无参数的构造方法
    - 提供用来操作成员变量的`set` 和`get` 方法



# 7 面向对象编程
## 7.1 继承
- 在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承的属性和方法。

### 7.1.1 继承的格式
```java
class 父类 {
	...
}

class 子类 extends 父类 {
	...
}
```

- 继承的好处
    - 提高**代码的复用性**。
    - 类与类之间产生了关系，是**多态的前提**。

### 7.1.2 继承后的特点
- 非私有成员变量
    - 若有重名，使用super、this关键字区分
- 非私有成员方法
    - 若有重名（返回值类型，方法名和参数列表都相同），方法重写
- 构造方法
    - 1. 构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。
    - 2. 构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个`super()` ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用

### 7.1.3 super和this
在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。
- super和this的含义
    - super：代表父类的**存储空间标识**(可以理解为父亲的引用)。
    - this：代表**当前对象的引用**(谁调用就代表谁)。
- super和this的用法
    - 访问成员
        - super.成员名
        - this.成员名
    - 访问构造方法
        - super();
        - this();

### 7.1.4 继承的特点
1.只支持单继承，不支持多继承。
2.Java支持多层继承(继承体系)。
3.所有的类都直接或者间接继承了Object类，Object类是所有类的父类。

## 7.2 抽象类
- 抽象方法：用抽象关键字abstract修饰的没有方法体的方法。
- 抽象类：含有抽象方法的类。

### 7.2.1 abstract使用格式
- 抽象方法——修饰符 abstract 返回值类型 方法名 (参数列表)；
- 抽象类——public abstract class 类名{}
- 抽象类的使用：继承抽象类的子类**必须重写父类所有的抽象方法**。
- 注意事项
    - 抽象类**不能创建对象**，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。
    - 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。
    - 抽象类中，可以有成员变量。
    - 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
    - 抽象类的子类，必须重写抽象父类中**所有的**抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类

### 7.2.2 final关键字
- final：不可改变。用于修饰类、方法和变量。
    - 类：被修饰的类，不能被继承
    - 方法：被修饰的方法，不能被重写。
    - 变量：被修饰的变量，不能被重新赋值。
        - 基本类型：基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。
        - 引用类型：引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。
        但是不影响对象内部的成员变量值的修改。
        - 成员变量：final修饰成员变量必须在创建对象之前赋值（方式：显示初始化、构造方法初始化二选一）。

## 7.3 接口
接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是**封装了方法**，接口中所有方法都是抽象方法。

### 7.3.1 接口的定义
- 定义格式
```java
public interface 接口名称 {
    // 抽象方法
    // 抽象方法
 
}
```
- 定义接口与定义类的不同
1.接口中的方法均为公共访问的抽象方法
2.接口中无法定义普通的成员变量

### 7.3.2 接口中成员的特点
- 抽象方法：接口中可以定义方法，方法也有固定的修饰符，public abstract。
- 常量：接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。
- 接口没有构造方法,不能直接创建对象。

### 7.3.3 接口的特点(注意事项)
- 类与类是继承关系,类与接口是实现关系,一个类可以在继承一个类的同时实现多个接口
- 接口与接口的关系继承关系,可以单继承,也可以多继承

### 7.3.4 接口的好处
- 接口解决了java单继承的局限性,提高了程序的扩展性
- 接口的出现降低了耦合性，即设备与设备之间实现了解耦

### 7.3.5 抽象类与接口的区别
- 相同点
    - 都包含抽象方法,其子类都必须覆写这些抽象方法
    - 都不能直接实例化对象;
    - 都位于继承的顶端,用于被其他类实现或继承;
- 区别
    - 抽象类为部分方法提供实现,避免子类重复实现这些方法,提高代码重用性;接口只能包含抽象方法;
    - 一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;(接口弥补了Java的单继承)；
    - 抽象类为继承体系中的共性内容,接口为继承体系中的扩展功能。
    成员区别
        - 抽象类：变量、常量、构造方法、抽象方法、非抽象方法
        - 接口：常量、抽象方法
    关系区别
        - 类与类：单继承
        - 接口与接口：单继承、多继承
        - 接口与类：可以单实现，也可以多实现
    设计理念区别
        - 抽象类：对类抽象，包括属性、行为
        - 接口：对行为抽象，主要是行为

## 7.4 多态
- 前提条件
1.继承或者实现【二选一】
2.方法的重写【意义体现：不重写，无意义】
3.父类引用指向子类对象【格式体现】

### 7.4.1 多态的定义格式
```java
Fu fu = new zi；
```

### 7.4.2 多态的成员特点
- 多态调用变量时
    - 编译时期：到父类中找有没有这个变量,如果有编译成功,如果没有编译失败.
    - 运行时期：访问的是父类成员变量的值
    - 简而言之：编译看=号左边,运行看=左边。
- 多态调用方法时
    - 编译时期：到父类中去找这个方法,如果有编译成功,如果没有编译失败
    - 运行时期：运行的是子类重写后的方法.
    - 简而言之：编译看左边，运行看右边。

### 7.4.3 多态的转型
- 向上转型
```java
Fu fu = new zi；
```
- 向下转型
```java
Fu fu = new zi；
Zi zi = （Zi）fu；
```
-为什么要转型：不能调用子类拥有，而父类没有的方法。想要调用子类特有的方法，必须做向下转型。

- 转型的异常：当两个类型并没有任何继承关系，不符合类型转换的定义时，会发生ClassCastException错误。
    - Java提供了 `instanceof` 关键字，给引用变量做类型的校验，格式如下：
```java
变量名 instanceof 数据类型 
如果变量属于该数据类型，返回true。
如果变量不属于该数据类型，返回false。
```

## 7.5 总结封装、继承、多态的作用：
- 封装：把对象的属性与方法的实现细节隐藏，仅对外提供一些公共的访问方式
- 继承：子类会自动拥有父类所有可继承的属性和方法。
- 多态：配合继承与方法重写提高了代码的复用性与扩展性；如果没有方法重写，则多态同样没有意义。

## 7.6 静态
### 7.6.1 static关键字
- 特点：被static修饰的成员变量属于类，不属于这个类的某个对象。
- 使用格式*
```java
public static 类型 变量名 = 变量值；
public static viod 方法名（）{}
```
### 7.6.2 静态原理（static修饰的内容）
- 是随着类的加载而加载的，且只加载一次。
- 存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。
- 它优先于对象存在，所以，可以被所有对象共享。

### 7.6.3 静态代码块
定义在成员位置，使用static修饰的代码块{ }。
- 位置：类中方法外。
- 执行：随着类的加载而执行且执行一次，优先构造方法的执行。*
- 格式*
```java
public class Person {
	private String name;
	private int age;
 //静态代码块
	static{
		System.out.println("静态代码块执行了");
	}
}
```

### 7.6.4 静态常量
定义格式*
```java
public static final 数据类型 变量名 = 值;
```

### 7.6.5 静态导入
静态导入格式
```java
import static 包名.类名.方法名;
import static 包名.类名.*;
```

###不同权限的访问能力
|  | 公共的 | 受保护的 | 默认的 | 私有的 |
| --- | --- | --- | --- | --- |
|  | public | protected | default(空的) | private |
| --- | --- | --- | --- | --- |
| 同一类中 | √ | √ | √ | √ |
| 同一包中(子类与无关类) | √ | √ | √ |  |
| 不同包的子类 | √ | √ |  |  |
| 不同包的无关类 | √ |  |  |  |

- 编写代码时，如果没有特殊的考虑，建议这样使用权限：
    - 成员变量使用`private` ，隐藏细节。
    - 构造方法使用` public` ，方便创建对象。
    - 成员方法使用`public` ，方便调用方法。


## 7.7 匿名对象
- 特点
    - 1.创建匿名对象直接使用，没有变量名。
    - 2.匿名对象在没有指定其引用变量时，只能使用一次。
    - 3.匿名对象可以作为方法接收的参数、方法返回值使用。

## 7.8 内部类
概述：
### 7.8.1 成员内部类
- 定义在类中方法外的类。
定义格式
```java
public class 外部类{
    public class 内部类{
        
    }
}
```
###访问特点
- 内部类可以直接访问外部类的成员，包括私有成员。
- 外部类要访问内部类的成员，必须要建立内部类的对象。
创建格式
```java
外部类名.内部类名 对象名 = new 外部类型().new 内部类型()；
```

### 7.8.2 匿名内部类
- 是内部类的简化写法。它的本质是一个`带具体实现的` `父类或者父接口的` `匿名的` **子类对象**。
- 创建前提：存在一个**类或者接口**，这里的**类可以是具体类也可以是抽象类**。*
创建格式
```java
new 父类名或者接口名(){
    // 方法重写
    @Override 
    public void method() {
        // 执行语句
    }
};
```

## 7.9 引用类型的传递
### 7.9.1 类名作为方法参数和返回值
- 类名作为方法的形参
  方法的形参是类名类，其实需要的是该类的对象
  实际传递的是该对象的【地址值】】
- 类名作为方法的返回值
  方法的返回值是类名，其实返回的是该类的对象
  实际传递的，也是该对象的【地址值】

### 7.9.2 抽象类作为形参和返回值
- 抽象类作为形参和返回值
  - 方法的形参是抽象类名，其实需要的是该抽象类的子类对象
  - 方法的返回值是抽象类名，其实返回的是该抽象类的子类对象

### 7.9.3 接口名作为形参和返回值
- 接口作为形参和返回值
  - 方法的形参是接口名，其实需要的是该接口的实现类对象
  - 方法的返回值是接口名，其实返回的是该接口的实现类对象

# 8 异常
## 8.1 异常
- 指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。

### 8.1.1 异常体系
- Throwable体系
    - Error：严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。
    - Exception：表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。
- Throwable常用方法
    - public void printStackTrace():打印异常的详细信息。
    包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。
    - public String getMessage():获取发生异常的原因。
    提示给用户的时候,就提示错误原因。
    - public String toString():获取异常的类型和异常描述信息(不用)。


### 8.1.2异常分类
- 编译时异常：checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)
- 运行时异常runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)

### 8.1.3 异常处理
- 抛出异常throw
    - 创建一个异常对象。封装一些提示信息(信息可以自己编写)。
    - 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。throw**用在方法内**，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。
- 声明异常throws
    - 将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。关键字**throws**运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常)。
    - 格式：修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{   }	
- 捕获异常try...catch
    - Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。
    - 格式：
```java
    try{
     编写可能会出现异常的代码
}catch(异常类型  e){
     处理异常的代码
     //记录日志/打印异常信息/继续抛出异常
}
```
- finally代码块
    - **finally**：有一些特定的代码无论异常是否发生，都需要执行。
    - finally的语法:try...catch....finally:自身需要处理异常,最终还得关闭资源。
- 异常注意事项
    - 运行时异常被抛出可以不处理。即不捕获也不声明抛出。
    - 如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是他的子集。
    - 父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出
    - 当多异常处理时，捕获处理，前边的类不能是后边类的父类
    - 在try/catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。
    - 多个异常使用捕获又该如何处理呢？
        1. 多个异常分别处理。
        2. 多个异常一次捕获，多次处理。
        3. 多个异常一次捕获一次处理。

一般我们是使用一次捕获多次处理方式，格式如下：
```java
try{
     编写可能会出现异常的代码
}catch(异常类型A  e){  当try中出现A类型异常,就用该catch来捕获.
     处理异常的代码
     //记录日志/打印异常信息/继续抛出异常
}catch(异常类型B  e){  当try中出现B类型异常,就用该catch来捕获.
     处理异常的代码
     //记录日志/打印异常信息/继续抛出异常
}
```

### 8.1.4 自定义异常
- 异常类如何定义:
    - 1. 自定义一个编译期异常: 自定义类 并继承于`java.lang.Exception`。
    - 2. 自定义一个运行时期的异常类:自定义类 并继承于`java.lang.RuntimeException`。

# 9 数据结构
## 9.1 栈
- **栈**：**stack**,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。
- 特点：
    - 先进后出；
    - 栈的入口、出口的都是栈的顶端位置。

## 9.2 队列
- **队列**：**queue**,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。
- 特点：
    - 先进先出；
    - 队列的入口、出口各占一侧。

## 9.3 数组
- **数组**:**Array**,是有序的元素序列，数组是在内存中开辟一段**连续**的空间，并在此空间存放元素。
- 特点：查找快，增删慢。

## 9.4 链表
- **链表**:**linked list**,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。
- 特点：查找慢，增删快。


# 10 集合
## 10.1 集合常用类继承体系图
```
flowchart LR
    Collection --> List 
    Collection --> Set
    List --> ArrayList
    List --> LinkedList
    Set --> HashSet --> LinkedHashSet
    Set --> TreeSet
```

## 10.2 Collections 集合
- 常用功能
    - `java.utils.Collections`是集合工具类，用来对集合进行操作。
- 常用方法如下：
    - `public static void shuffle(List<?> list) `:打乱集合顺序。
    - `public static <T> void sort(List<T> list)`:根据元素的自然顺序 对指定列表按升序进行排序
    - `public static <T> void sort(List<T> list，Comparator<? super T> )`:将集合中元素按照指定规则排序。
- 重写自然排序方法
static void sort(List  list),集合中的元素必须实现自然排序接口 Comparable,重写compareTo方法指定比较的规则。
像 String Integer 这些java提供的类都已经实现过了 可以直接使用

```java
public class Person implements Comparable<Person>{
    private String name;
    private int age;
    private double height;
    ...
        @Override
    public int compareTo(Person other) {
        //this 和 other的比较
        if(this.age == other.age){
//            return (int) (this.height - other.height);
            return  Double.compare(this.height,other.height);
        }
        return  this.age - other.age;
//        return  other.age - this.age;
    }
}
```
- 创建比较器
static void sort(List list, Comparator c)此时集合中的元素 可以不实现自然排序接口
此时的比较规则 使用的是比较器的比较规则Comparator
```java
Collections.sort(list, new Comparator<Student>() {
            @Override
            public int compare(Student o1, Student o2) {
                return Double.compare(o1.getScore(),o2.getScore());
            }
        });
```

## 10.3 Iterator迭代器
- **迭代**：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个
- 元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。
Iterator接口的常用方法如下：
- `public E next()`:返回迭代的下一个元素。
- `public boolean hasNext()`:如果仍有元素可以迭代，则返回 true。

```java
Collection<String> coll = new ArrayList<String>();
coll.add("汪星人"，"喵星人"，"牛星人")
Iterator it = coll.iterator();
while(it.hasNext()){
    String s = it.next();
}
```

## 10.4 增强for循环
增强for循环(也称for each循环)是**JDK1.5**以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理Iterator迭代器，在遍历的过程中，不能对集合中的元素进行增删操作。
格式
```java
for(元素的数据类型  变量 : Collection集合or数组){ 
  	//操作代码
}
```

## 10.5 List集合
`java.util.List`接口继承自`Collection`接口，是单列集合的一个重要分支，习惯性地会将实现了`List`接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。
- 特点：
    - 是一个存取有序的集合；
    - 带有索引；
    - 集合中可有重复元素。可通过equals方法判断是否为重复元素。
- List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：
    - `public void add(int index, E element)`: 将指定的元素，添加到该集合中的指定位置上。
    - `public E get(int index)`:返回集合中指定位置的元素。
    - `public E remove(int index)`: 移除列表中指定位置的元素, 返回的是被移除的元素。
    - `public E set(int index, E element)`:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。

### 10.5.1 ArrayList集合
- 数据存储的结构是数组结构。
- 特点：
    - 有序 有索引 元素可重复
    - 底层数据结构是数组  查询快 增删慢
    - 初始容量为10 新容量为 老容量的1.5倍
    - 线程不安全 效率高

### 10.5.2 LinkedList集合
- 数据存储的结构是链表结构（双向链表）。
- 特点：
    - 有序 有索引 元素可重复
    - 底层数据结构是链表  查询慢 增删快
    - 线程不安全 效率高

### 10.5.3 Vector
- 特点
    - 有序 有索引 元素可重复
    - 底层数据结构是数组 查询快 增删慢
    - 线程安全 效率低
    - Vector扩容是老容量的2倍

## 10.6 Set接口
`java.util.Set`接口继承自`Collection`接口，比`Collection`接口更加严格了。与`List`接口不同的是，`Set`接口中元素无序，并且不出现重复。
- 特点
    - 元素唯一
- 常用实现类
    - TreeSet  排序 唯一
    - HashSet  无序 唯一
    - LinkedHashSet  有序 唯一

### 10.6.1 TreeSet集合
使用元素的[自然顺序]对元素进行排序，或者根据创建 set 时提供的 [`Comparator`] 进行排序，具体取决于使用的构造方法。
- 特点：排序、唯一。
- 构造方法：

| 构造方法 | 描述 |
| --- | --- |
| public TreeSet() | 构造一个新的空 set，该 set 根据其元素的自然顺序进行排序。 |
| public TreeSet(Comparator<? super E> comparator) | 构造一个新的空 TreeSet，它根据指定比较器进行排序。 |

### 10.6.2 HashSet集合
- `java.util.HashSet`是`Set`接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的。`java.util.HashSet`底层的实现其实是一个`java.util.HashMap`支持。
- 特点：无序、唯一
- `HashSet`是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存储和查找性能。保证元素唯一性的方式依赖于：`hashCode`与`equals`方法。
    - 两个字符串的内容不同但是哈希值却相同? 比如"重地"和"通话"这两个字符串内容不同但是hashCode值相同.虽然这种情况不多见,但是是真实存在的,所以要比较两个字符串是否相同,光靠比较hashCode是不行的,还需要继续比较equals内容，为了提高速度,先比较hashCode再比较equals。

### 10.6.3 HashSet集合存储数据的结构（哈希表）
- 哈希表的初始化容量，数组长度为16个，加载因子为0.75。
  - 当数组容量不够时，扩容为原数组长度的2倍。
  - 指示当数组的容量被使用到长度的75%时，进行扩容。
  - HashSet 迭代所需迭代时间与其容量 成正比。 

### 10.6.4 LinkedHashSet
- HashSet的子类`java.util.LinkedHashSet`，它是链表和哈希表组合的一个数据存储结构。
- 特点：
    - 底层数据结构是链表 + 哈希表。
    - 有序、唯一。
    - 初始化容量，数组长度为16个，加载因子为0.75。
    - LinkedHashSet 迭代所需时间与 set 的大小 成正比，而与容量无关。

## 10.7 Map集合(映射)
- `Collection`中的集合称为单列集合，`Map`中的集合称为双列集合。
- 需要注意的是，`Map`中的集合不能包含重复的键，值可以重复，每个键只能对应一个值。
- 常用方法：
    - `public V put(K key, V value)`:  把指定的键与指定的值添加到Map集合中。
    - `public V remove(Object key)`: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。
    - `public V get(Object key)` 根据指定的键，在Map集合中获取对应的值。
    - `public Set<K> keySet()`: 获取Map集合中所有的键，存储到Set集合中。
    - `public Set<Map.Entry<K,V>> entrySet()`: 获取到Map集合中所有的键值对对象的集合(Set集合)。
    - `public boolean containKey(Object key)`:判断该集合中是否有此键。
    - `public Collection<V> values()` 返回Map集合中的所有值到Collection集合。
- 遍历方式：
    - 键找值方式：通过元素中的键，获取键所对应的值；
    - 键值对方式：通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。

### 10.7.1 HashMap集合
- Map接口实现类HashMap类特点：
    - 底层哈希表结构。
    - 不允许重复键。
        - 用作键的对象，应该重写hashCode()方法和equals()方法。
    - 此集合可以使用null值和null键。
    - 线程不安全，运行速度快。

- HashMap存储自定义对象
    - 给HashMap中存放自定义对象时，若自定义对象作为key存在，要保证对象唯一，必须复写对象的hashCode和equals方法。
    - 如果要保证map中存放的key和取出的顺序一致，可以使用`java.util.LinkedHashMap`集合来存放。

### 10.7.2 LinkedHashMap集合
- 特点：
    - 有序、成对元素唯一、查询速度快；
    - 底层是哈希表双向链表，保证迭代的顺序。

### 10.7.3 Properties集合
Map接口实现类Hashtable的子类Properties类。Properties也是Map接口实现类，是存储键值对的双列集合，由于此类能和IO流结合使用，数据可以持久化，使用量很大。
- Properties集合特点：
    - 继承Hashtable，底层数据结构是哈希表。
    - 线程安全，运行速度慢。
    - 不允许null值，null键。
    - 此集合存储键值对数据类型固定为String。
    - 可以和IO流结合使用，从流中加载数据。
- Properties集合特有方法：
    - `Object setPropery(String key,String value)`，向集合中存储键值对。
    - `String getProperty(String key)`，获取集合中键对应的值，无此键返回null。
    - `Set<String> stringPropertyNames()`，集合中的所有键存储到Set集合。
    - `void load(输入流对象)`。

### 10.7.4 TreeMap集合
TreeMap集合基于红黑树实现,该映射根据其键的[自然顺序]进行排序，或者根据创建映射时提供Comparator
进行排序，具体取决于使用的构造方法。
| 构造方法                                  | 描述                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| TreeMap()                                 | 使用键的自然顺序构造一个新的、空的树映射。                   |
| TreeMap(Comparator<? super K> comparator) | 构造一个新的、空的树映射，该映射根据给定比较器进行排序。     |
| TreeMap(Map<? extends K,? extends V> m)   | 构造一个与给定映射具有相同映射关系的新的树映射，该映射根据其键的*自然顺序* 进行排序。 |

- `public Map.Entry<K,V> ceilingEntry(K key)`:  返回一个键-值映射关系，它与大于等于给定键的最小键关联；如果不存在这样的键，则返回 null。 
- `public K ceilingKey(K key)`: 返回大于等于给定键的最小键；如果不存在这样的键，则返回 null。 
- `public Map.Entry<K,V> firstEntry()` 返回一个与此映射中的最小键关联的键-值映射关系；如果映射为空，则返回 null。 
- `public Map.Entry<K,V> lastEntry()`: 返回与此映射中的最大键关联的键-值映射关系；如果映射为空，则返回 null。 
- `public K firstKey()`: 返回此映射中当前第一个（最低）键。
- `public K lastKey()`:返回映射中当前最后一个（最高）键。 

## 10.8 可变参数
在**JDK1.5**之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化。
- 格式：修饰符 返回值类型 方法名(参数类型... 形参名){  }
- 注意：
    - 可变参数的本质是数组。
        - 不传递参数，数组的长度是0.
        - 传递几个参数，数组的长度就是几。
    - 一个方法中只能有一个可变参数。
    - 如果方法中有多个参数，可变参数只能写在最后一位。

## 10.9 正则表达式
正则表达式是对字符串操作的一种规则，事先定义好一些字符串，这些字符串称为规则字符串，使用规则字符串表达一些逻辑功能。

- 正则规则-字符类

| 规则写法    | 规则含义                                    |
| ----------- | ------------------------------------------- |
| [abc]       | a、b 或 c（简单类）                         |
| [^abc]      | 任何字符，除了 a、b 或 c（否定）            |
| [a-zA-Z]    | a 到 z 或 A到 Z，两头的字母包括在内（范围） |
| [0-9]       | 0到9，两头的数字包括在内（范围）            |
| [a-zA-Z0-9] | a 到 z 或 A到 Z或0-9                        |

- 正则规则-预定义字符类

| 规则写法 | 规则含义                  |
| -------- | ------------------------- |
| .        | 任何字符                  |
| \d       | 数字[0-9]                 |
| \D       | 非数字 `[^0-9]`           |
| \w       | 单词字符 [a-zA-Z0-9_]     |
| \W       | 非单词字符`[^a-zA-Z0-9_]` |

- 正则规则-数量词

| 规则写法 | 规则含义                       |
| -------- | ------------------------------ |
| X{?}     | 一次或一次也没有               |
| X{*}     | 零次或多次                     |
| X{+}     | 一次或多次                     |
| X{n}     | 恰好 *n* 次                    |
| X{n,}    | 至少 *n* 次                    |
| X{n,m}   | 至少 *n* 次，但是不超过 *m* 次 |




# 11 多线程
## 1.1 并发与并行
- 并发：指两个或多个事件在**同一时刻**发生（同时发生）
- 并行：- 指两个或多个事件在**同一个时间段内**发生。

## 11.2 线程与进程
- 线程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位。
- 进程：是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。

- 线程与进程的区别
    - 进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。
    - 线程：堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。

## 11.3 线程的创建
### 11.3.1 线程的创建-继承方式
Java使用 java.lang.Thread 类代表线程，所有的线程对象都必须是Thread类或其子类的实例。
- 创建并启动多线程的步骤
    - 1.定义Thread类的子类，并重写该类的run()方法；
    - 2.创建Thread子类的实例，即创建了线程对象；
    - 3.调用线程对象的start()方法来启动该线程。

#### run()方法和start()方法
- run()方法，是线程执行的任务方法，每个线程都会调用run()方法执行，我们将线程要执行的任务代码都写在run()方法中就可以被线程调用执行。
- start()方法，开启线程，线程调用run()方法。start()方法源代码中会调用本地方法start0()来启动线程：`private native void start0()`，本地方法都是和操作系统交互的，因此可以看出每次开启一个线程的线程都会和操作系统进行交互。
  - 注意：一个线程只能被启动一次！

#### 线程名字的设置和获取
- Thread类的方法`String getName()`可以获取到线程的名字。
- Thread类的方法`setName(String name)`设置线程的名字。
- 通过Thread类的构造方法`Thread(String name)`也可以设置线程的名字。

#### 获取运行main方法线程的名字
- Demo类不是Thread的子类，因此不能使用getName()方法获取。
- Thread类定义了静态方法`static Thread currentThread()`获取到当前正在执行的线程对象。
- main方法也是被线程调用了，也是具有线程名字的。


### 11.3.2 线程的创建-实现方式
#### 实现Runnable接口
采用`java.lang.Runnable`也是非常常见的一种，我们只需要重写run方法即可。
步骤如下：
1. 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
2. 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
3. 调用线程对象的start()方法来启动线程。
```java
public class MyRunnable implements Runnable{
	public void run() {
		for (int i = 0; i < 20; i++) {
			System.out.println(Thread.currentThread().getName()+" "+i);
		}
	}
}
```

```java
public class Demo {
    public static void main(String[] args) {
        //创建自定义类对象  线程任务对象
        MyRunnable mr = new MyRunnable();
        //创建线程对象
        Thread t = new Thread(mr);
        t.start();
    }
}
```

#### Thread和Runnable的区别
如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。
- 实现Runnable接口比继承Thread类所具有的优势:
    - 1.适合多个相同的程序代码的线程去共享同一个资源。
    - 2.可以避免java中的单继承的局限性。
    - 3.增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。

#### 匿名内部类方式创建线程
使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。
使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法：
```java
public class NoNameInnerClassThread {
   	public static void main(String[] args) {	
   	Runnable r = new Runnable(){
            public void run(){
                for (int i = 0; i < 20; i++) {
                  	System.out.println("张宇:"+i);
                }
            }  
        };
    new Thread(r).start();
```

### 11.3.3 Callable接口
Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法,叫做call()。
这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。
那么如何使用Callable接口呢?
1.定义类实现Callable接口 
2.重写call方法 
3.开启线程
```java
public class MyCall implements Callable<Integer> {
    private int n;
    public MyCall(int n){
        this.n = n;
    }
    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += i;
        }
        return sum;
    }
}

public class Test {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyCall myCall = new MyCall(100);
        FutureTask<Integer> ft = new FutureTask<>(myCall);
      // 需要注意Thread类并没有接收Callable接口的构造方法
      //所以需要使用FutureTask包装一下 再传入到Thread类中
        Thread t = new Thread(ft);
        t.start();
        System.out.println(ft.get());
    }
}
```

## 11.4 Thread类API
### 11.4.1 睡眠sleep方法
- public static void sleep(long time) 让当前线程进入到睡眠状态，到毫秒后自动醒来继续执行。

### 11.4.2 设置线程优先级
- public final void setPriority(int newPriority 更改线程的优先级。
- 线程的优先级被划分为10级,值分别为1-10,其中1最低,10最高.线程提高了3个常量来表示最低,最高,以及默认优先级:
```java
public static final int MIN_PRIORITY //1 最低优先级
public static final int NORM_PRIORITY //5 默认优先级
public static final int MAX_PRIORITY //10 最大优先级
```

### 11.4.3 用户线程与守护线程
- public final void setDaemon(boolean on) on的值为true将线程设置为守护线程,注意一定要在开启线程之前设置。
- java分为两种线程:用户线程和守护线程。
- 所谓守护线程是指程序运行的时候在后台提供一种通用的服务的线程。
守护线程和用户线程没有本质的区别:唯一不同之处就在于虚拟机的离开:如果用户线程已经全部退出运行了,只剩下守护线程存在,虚拟机会直接退出.但是只要有用户线程运行,虚拟机就不会退出.

### 11.4.4 join方法
join方法是让当前线程等待,调用方法的线程进行插队先执行,执行完毕后,在让当前线程执行.对其他线程没有任何影响。注意 此处的当前线程不是调用方法的线程 而是Thread.currentThread()。


## 11.5 线程安全
线程安全问题引发：线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。

### 11.5.1 线程同步
要解决多线程并发访问一个资源的安全性问题，Java中提供了同步机制(synchronized)来解决。
- 同步代码块
- 同步方法
- 锁机制

#### 同步代码块
- 同步代码块：线程操作的共享数据进行同步。synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。
格式：
```java
synchronized(同步锁){
     需要同步操作的代码
}
```
**注意**：线程运行至同步代码块的时候，需要判断锁，获取锁，出去同步代码块后要释放锁，增加了很多操作，因此线程安全，程序的运行速度慢！

- 同步锁:同步锁又称为对象监视器。同步锁只是
    - 1. 锁对象 可以是任意类型。
    - 2. 多个线程对象 要使用同一把锁

#### 同步方法
- 同步方法:当一个方法中的所有代码，全部是线程操作的共享数据的时候，可以将整个方法进行同步。使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。
格式：
```java
public synchronized void method(){
   	可能会产生线程安全问题的代码
}
```
- 同步锁是谁?
    - 对于非static方法,同步锁就是this。
    - 对于static方法,我们使用当前方法所在类的字节码对象(类名.class)

#### Lock锁
java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广
泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。
- Lock锁也称同步锁，加锁与释放锁方法化了，如下：
    - public void lock() :加锁。
    - public void unlock() :释放锁。
```java
Lock lock = new ReentrantLock();
lock.lock();
lock.unlock();
```

## 11.6 线程状态
当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程命周期中，有几种状态呢？在API中java.lang.Thread.State这个枚举中给出了六种线程状态：

| 线程状态                | 导致状态发生条件                                             |
| ----------------------- | ------------------------------------------------------------ |
| NEW(新建)               | 线程刚被创建，但是并未启动。还没调用start方法。              |
| Runnable(可运行)        | 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。 |
| Blocked(锁阻塞)         | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 |
| Waiting(无限等待)       | 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。 |
| Timed Waiting(计时等待) | 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。 |
| Teminated(被终止)       | 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 |

### 11.6.1 等待和唤醒
线程等待和唤醒的方法定义在`java.lang.Object`类中。

| 方法含义                                     | 方法声明                      |
| -------------------------------------------- | ----------------------------- |
| 当前线程等待，当前线程必须拥有此对象监视器。 | public final void wait()      |
| 唤醒在此对象监视器上等待的单个线程。         | public final void notify()    |
| 唤醒在此对象监视器上等待的所有线程。         | public final void notifyAll() |

### 11.6.2 sleep()和wait()方法的区别
- sleep()是Thread类静态方法，不需要对象锁。
- wait()方法是Object类的方法，被锁对象调用，而且只能出现在同步中。
- 执行sleep()方法的线程不会释放同步锁。
- 执行wait()方法的线程要释放同步锁，被唤醒后还需获取锁才能执行。

### 11.6.3 死锁
死锁是指两个或两个以上的线程在执行过程中，由于竞争同步锁而产生的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的线程称为死锁。

### 11.6.4 Condition接口
`Condition` 将 `Object` 监视器方法（`wait`、`notify` 和 `notifyAll`）分解成截然不同的对象，以便通过将这些对象与任意 `Lock`实现组合使用，为每个对象提供多个等待set（wait-set）。其中，`Lock`替代了`synchronized`方法和语句的使用，`Condition` 替代了` Object` 监视器方法的使用。

- Lock接口的方法newCondition()获取: `public Condition newCondition()`
- 常用方法：

| 方法声明                | 方法含义           |
| ----------------------- | ------------------ |
| public void await()     | 线程等待           |
| public void signal()    | 唤醒一个等待的线程 |
| public void singalAll() | 唤醒所有等待的线程 |

#### Condition接口方法和Object类方法比较
- Condition可以和任意的Lock组合，也就是实现了线程的分组管理。
  - 一个线程的案例中，可以使用多个Lock锁，每个Lock锁上可以结合Condition对象
  - synchronized同步中做不到线程分组管理
- Object类wait()和notify()都要和操作系统交互，并通知CPU挂起线程，唤醒线程，效率低。
- Condition接口方法await()不和操作系统交互，而是让线程释放锁，并存放到线程队列容器中，当被signal()唤醒后，从队列中出来，从新获取锁后在执行。
- 因此使用Lock和Condition的效率比Object要快很多。

## 11.7 JMM模型
详解：https://blog.csdn.net/javazejian/article/details/72772461
### 11.7.1 CPU多核并发缓存架构
**CPU工作原理**
- 首先CPU工作的时候，由控制单元充当大脑，负责协调。
- 让运算单元做运算的时候，会首先从最靠近CPU的寄存器（其实是和CPU一体的）上读取数据，在寄存器上有CPU运行的常用指令
- 如果寄存器上没有想要的数据，则就从三级缓存的L1级缓存中获取，如果L1取到数据了，会加载到寄存器中，再转输给CPU运算单元。
- 如果L1中没有，则从L2级缓存中读取，同理，如果没有，则从L3中取。
- 如果L3中也没有，这个时候，就比较麻烦了。要从主内存中取。
- 而**从主内存中取的时候，会经过系统总线及内存总线,这时因受到总线的限制，速度会大大降低。而且会存在众多问题。**

**为什么要加入缓存**
再计算机最开始的时候，cpu直接于主内存交换数据，由于cpu性能日新月异的增长，远高于主内存读写，而需要等待主内存，这样发挥不了多核cpu高性能的优势，于是便增加了cpu多级缓存.读入缓存,下次用时从缓存读取,效率会大大提高。
基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：**缓存一致性（Cache Coherence）**。在多处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存，如下图所示：多个处理器运算任务都涉及同一块主存。
如果cpu1改变了从主内存中读取的一个数据,而cpu2也刚好访问同一块区域也需要读取这个数据,那么读到的就会是未改变的值,造成缓存不一致。
那么为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。常用的方法是总线加锁或是缓存一致性协议-`MESI`。

### 11.7.2 Java多线程内存模型概述
Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。


## 11.8 Java并发编程的三大特性
在JAVA并发编程，如果要保证程序的线程安全，就要保证代码的原子性、可见性、有序性。

### 11.8.1 原子性
原子性，即一个操作或多个操作，要么全部执行并且在执行的过程中不被打断，要么全部不执行。（提供了互斥访问，在同一时刻只有一个线程进行访问.)

- JAVA本身的原子性:由JAVA内存模型来直接保证具有原子性变量操作的有read/load/use/assign/store/write，也就是说对于基本数据类型的赋值，读取操作时具有原子性的。
- 
- JAVA提供了原子性的技术保障有如下：
    - 1、synchronized （互斥锁）
    - 2、Lock（互斥锁）
    - 3、原子类(CAS)

#### 原子类AtomicInteger
```java
/*
    java.util.concurrent.atomic.AtomicInteger
    构造方法
        public AtomicInteger()创建具有初始值 0 的新 AtomicInteger。
        public AtomicInteger(int initialValue) 创建具有给定初始值的新 AtomicInteger。
      方法
        int incrementAndGet()  以原子方式将当前值加 1。
        int getAndIncrement()  以原子方式将当前值加 1。

        int decrementAndGet()  以原子方式将当前值减 1。
        int getAndIncrement()  以原子方式将当前值减 1。


        int getAndAdd(int delta)  以原子方式将给定值与当前值相加。
        int addAndGet(int delta)  以原子方式将给定值与当前值相加。
        int get() 获取当前值。
 */
 public class Test {
    static  int num = 0;
    static  AtomicInteger ai = new AtomicInteger(0);
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10000; i++) {
                    num++;
                    ai.incrementAndGet();
                }
            }
        });
        t1.start();
        System.out.println(ai);
    }
}
 ```
#### CAS无锁机制
CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。当多条线程尝试使用CAS同时更新同一个变量时,只有其中一条线程能更新变量的值,而其他线程都失败,失败的线程并不会被挂起,而是告知这次竞争失败,并可以再次尝试。
CAS机制当中使用了3个基本操作数：一个当前内存值V、旧的预期值A、即将更新的值B,当且仅当预期值A和内存值V相同时,将内存值修改为B,如果不相等,cas失败,返回当前内存值V。
- CAS的缺点：
    - 1. 循环时间长开销很大。	
   ```java
   CAS 通常是配合无限循环一起使用的，如果 CAS 失败，会一直进行尝试。如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销。
   ```
    - 2. 只能保证一个变量的原子操作。

   ```java
   当对一个变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个变量操作时，CAS 目前无法直接保证操作的原子性。
   ```
    - 3. ABA问题。
   ```java
   第一条线程获取到V位置的值  假设是 1
   第二条线程获取到V位置的值  也是1
   第一条线程cas成功 将值改为 0
   第一条线程又cas成功 将值改回 1
   这时第二条线程cas 发现值没变 还是1 cas成功   
   实际上当第二条线程cas时 V位置的值已经从 1-0-1
   这就是ABA问题 
   如何解决 每次获取V位置的值时,带上一个版本号.这样就可以避免ABA问题 java中AtomicStampedReference这个类在cas时就是通过版本号来解决的
   ```

- 悲观锁和乐观锁:
    - 悲观锁:简单来说操作系统会悲观的认为如果不严格同步线程调用那么一定会产生异常.所以互斥锁将会锁定资源,只供一个线程调用.而阻塞其他线程.因此这种同步机制也叫做悲观锁。
    - 乐观锁:比如CAS不会对资源进行锁定,而且当线程需要修改共享资源时,总是会乐观的认为值没有被其他线程修改过,而自己主动尝试修改对应的值.相较于悲观锁,这种同步机制称为乐观锁。

### 11.8.2 可见性
当多个线程访问同一个变量时,一个线程修改了这个变量的值,其他线程应该能够立即看得到修改的值。
我们现在多线程操作数据,对变量的修改都是在自己的本地内存(私有内存)中,再写回到主内存,一条线程将数据写回到主内存,其他线程用的还是自己本地内存(私有内存)中的共享副本,没有保证可见性.那么如何保证可见性呢?
- 1.加锁,比如使用synchronized.
```java
JMM关于synchronized的两条规定：
　　1）线程解锁前，必须把共享变量的最新值刷新到主内存中
　　2）线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值
```

使用同步的确解决了可见性的问题,但是每次循环都要走同步方法,加锁,解锁,效率低下,

- 2.使用volatile关键字保证可见性
    - volatile缓存可见性实现原理:
    ```java
    volatile int  a = 0;
    底层实现主要是通过汇编lock前缀指令,会锁住这块区域的缓存,并写回主内存.
    1.会将当前处理器缓存的行数据立即写回系统内存
    2.这个写回内存的操作导致CPU的缓存该内存地址的数值失效(MESI协议)
    **注意:**volatile只能保证可见性,但是不能保证原子性,如果要保证原子性,请使用锁。
    ```

### 11.8.3 有序性
一般来说,程序的执行顺序按照代码的先后顺序执行.但是处理器为了提高程序的效率,可能会对代码的执行顺序进行优化,它不保证程序中各个语句的执行先后顺序一致,但是保证程序的最终结果和代码顺序执行的结果一致。
CPU可能会对没有依赖关系的语句进行重排,比如 2134,3124 但是不会对有依赖关系的数据进行重排比如 3和4 改为4和3 这样就会对结果造成影响.这种重排对单线程是没有任何影响的,但是如果是多线程就可能会出现问题。

- volatile关键字有两个作用：
    - 1.保证可见性
    - 2.禁止重排序
```java
volatile int  a = 0;
```
**注意:锁也可以保证有序性,因为在代码块中,一次只有一个线程执行,系统重排对单线程执行是没有任何影响的.**

### 11.8.4 面试题:DCL单例是否需要使用volatile关键字?
理论上需要,但是实际上这种情况几乎不可能出现。

单例设计模式:单例代表单个实例,保证一个类的对象永远只有一个。
#### 饿汉式
```java
public class Singleton {
    // 将自身实例化对象设置为一个属性，并用static、final修饰
    private static final Singleton instance = new Singleton();
    // 构造方法私有化
    private Singleton() {}
    // 静态方法返回该实例
    public static Singleton getInstance() {
        return instance;
    }
}
```
- “饿汉模式”的优缺点：
    - 优点：实现起来简单，没有多线程同步问题。
    - 缺点：当类SingletonTest被加载的时候，会初始化static的instance，静态变量被创建并分配内存空间，从这以后，这个static的instance对象便一直占着这段内存（即便你还没有用到这个实例），当类被卸载时，静态变量被摧毁，并释放所占有的内存，因此在某些特定条件下会耗费内存。

#### 懒汉式(延迟加载)
延迟加载就是调用get()方法时实例才被创建。
```java
public class Singleton {
    // 将自身实例化对象设置为一个属性，并用static修饰
    private static Singleton instance;
    // 构造方法私有化
    private Singleton() {}
    // 静态方法返回该实例
    public static Singleton getInstance() {
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
- “懒汉模式”的优缺点：
    - 优点：实现起来比较简单，当类SingletonTest被加载的时候，静态变量static的instance没有创建对象，当getInstance方法第一次被调用时，才创建对象为其赋值，因此在某些特定条件下会节约了内存。
    - 缺点：在多线程环境中，这种实现方法是完全错误的，根本不能保证单例的状态。

#### 线程安全的“懒汉模式”
```java
public class Singleton {

    // 将自身实例化对象设置为一个属性，并用static修饰
    private static Singleton instance;
    
    // 构造方法私有化
    private Singleton() {}
    
    // 静态方法返回该实例，加synchronized关键字实现同步
    public static synchronized Singleton getInstance() {
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
- 优点：在多线程情形下，保证了“懒汉模式”的线程安全。
- 缺点：众所周知在多线程情形下，synchronized方法通常效率低，显然这不是最佳的实现方案。

#### DCL双检查锁机制单例（DCL：double checked locking）
```java
public class Singleton {
    // 将自身实例化对象设置为一个属性，并用static修饰
    private static /*volatile*/ Singleton instance;
    // 构造方法私有化
    private Singleton() {}
    // 静态方法返回该实例
    public static Singleton getInstance() {
        // 第一次检查instance是否被实例化出来，如果没有进入if块
        if(instance == null) {
            synchronized (Singleton.class) {
                // 某个线程取得了类锁，实例化对象前第二次检查instance是否已经被实例化出来，如果没有，才				最终实例出对象
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

```
DCL双检查锁机制单例,效率高，线程安全，多线程操作原子性。


## 11.9 阻塞队列与线程池
### 11.9.1 阻塞队列
阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。

| 队列                | 有界性             | 锁   | 数据结构   |
| ------------------- | ------------------ | ---- | ---------- |
| ArrayBlockingQueue  | bounded(有界)      | 加锁 | arrayList  |
| LinkedBlockingQueue | optionally-bounded | 加锁 | linkedList |
| SynchronousQueue    | bounded            | 加锁 | 无         |

- ArrayBlockingQueue：是一个用数组实现的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。支持公平锁和非公平锁。【注：每一个线程在获取锁的时候可能都会排队等待，如果在等待时间上，先获取锁的线程的请求一定先被满足，那么这个锁就是公平的。反之，这个锁就是不公平的。公平的获取锁，也就是当前等待时间最长的线程先获取锁。
- LinkedBlockingQueue：一个由链表结构组成的有界队列，此队列的长度为Integer.MAX_VALUE。此队列按照先进先出的顺序进行排序。
- SynchronousQueue： 一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。

常用方法：
```java
public void put(E e)将指定的元素插入此队列的尾部，如果该队列已满，则等待可用的空间。 
public E take()  获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。
```

### 11.9.2 线程池
创建线程每次都要和操作系统进行交互，线程执行完任务后就会销毁，如果频繁的大量去创建线程肯定会造成系统资源开销很大，降低程序的运行效率。
线程池思想就很好的解决了频繁创建线程的问题，我们可以预先创建好一些线程，把他们放在一个容器中，需要线程执行任务的时候，从容器中取出线程，任务执行完毕后将线程在放回容器。

- 使用线程池好处:
    - 1.降低资源消耗。通过重复利用已创建的线程降低线程创建、销毁线程造成的消耗。
    - 2.提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
    - 3.提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。

#### JDK线程池
`java.util.concurrent `包中定义了线程池相关的类和接口
#### Executors类

创建线程池对象的工厂方法，使用此类可以创建线程池对象。

| 方法声明                                                     | 方法含义                                                     |
| ------------------------------------------------------------ |------------------------------------------------------------ |
| static ExecutorService newFixedThreadPool(int nThreads)      | 创建一个可重用固定线程数的线程池。                           |
| static ExecutorService newCachedThreadPool()                 | 创建一个可根据需要创建新线程的线程池                         |
| static ExecutorService newSingleThreadExecutor()             | 创建一个使用单个 worker 线程的 Executor                      |
| static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) | 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。 |

#### ExecutorService接口
线程池对象的管理接口，提交线程任务，关闭线程池等功能。
| 方法声明                             | 方法含义                                                     |
| ------------------------------------ | ------------------------------------------------------------ |
| Future<?> submit(Runnable task)      | 提交线程执行的任务，方法将返回null，因为run()(方法没有返回值。 |
| <T>Future<T>submit(Callable<T> task) | 提交线程执行的任务，返回Future接口对象。                     |
| void shutdown()                      | 关闭线程池，但是要等所有线程都完成任务后再关闭，但是不接收新任务。 |

#### ThreadPoolExecutor自定义线程池
使用ThreadPoolExecutor去创建线程池：
```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
```


| 参数            | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| corePoolSize    | 核心线程数量，线程池维护线程的最少数量                       |
| maximumPoolSize | 线程池维护线程的最大数量                                     |
| keepAliveTime   | 线程池除核心线程外的其他线程的最长空闲时间，超过该时间的空闲线程会被销毁 |
| unit            | keepAliveTime的单位，TimeUnit中的几个静态属性：NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS |
| workQueue       | 线程池所使用的任务缓冲队列                                   |
| threadFactory   | 线程工厂，用于创建线程，一般用默认的即可                     |
| handler         | 线程池对拒绝任务的处理策略                                   |


当线程池任务处理不过来的时候（什么时候认为处理不过来后面描述），可以通过handler指定的策略进行处理，ThreadPoolExecutor提供了四种策略：
1. ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常；也是默认的处理方式。
2. ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。
3. ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
4. ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务
5.可以通过实现RejectedExecutionHandler接口自定义处理方式。

# 12 IO流
## 12.1 File类
`java.io.File` 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。File类将文件，文件夹和路径封装成了对象，提供大量的方法来操作这些对象。
- File类的静态成员变量
    - `static String pathSeparator` 与系统有关的路径分隔符。
    - `static String separator` 与系统有关的默认名称分隔符。

- 绝对路径和相对路径
```java
String path = "d:\\aaa\bbb\ccc\a.txt";//带盘符 绝对路径
String path2 = "a.txt"; //相对路径
```

- File类构造方法
    - `public File(String pathname) ` ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。  
    - `public File(String parent, String child) ` ：从父路径名字符串和子路径名字符串创建新的 File实例。
    - `public File(File parent, String child)` ：从父抽象路径名和子路径名字符串创建新的 File实例。

- File类的获取方法
    - `public String getAbsolutePath() ` ：返回此File的绝对路径名字符串。
    - ` public String getPath() ` ：将此File转换为路径名字符串。 
    - `public String getName()`  ：返回由此File表示的文件或目录的名称。  
    - `public long length()`  ：返回由此File表示的文件的长度。 
    - `public File getParentFile()`返回由此File表示的文件或目录的父目录，如果没有父目录，返回null。

- File类判断方法
    - `public boolean exists()` ：此File表示的文件或目录是否实际存在。
    - `public boolean isDirectory()` ：此File表示的是否为目录。
    - `public boolean isFile()` ：此File表示的是否为文件。

- File类创建删除功能的方法
    - `public boolean createNewFile()` ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 
    - `public boolean delete()` ：删除由此File表示的文件或目录。  不进回收站，直接删除。
    - `public boolean mkdirs()` ：创建由此File表示的目录，包括任何必需但不存在的父目录。

- File类目录遍历方法
    - `public File[] listFiles()`返回一个File数组，表示该File目录中的所有的子文件或目录、
    - `public File[] listFiles(FileFilter filter)`返回一个File数组，表示该File目录中的所有的子文件或目录，filter是文件过滤器，可以过滤不需要的文件。

- FileFilter接口
文件过滤器接口，此接口的实现类可以传递给方法listFiles()，实现文件的过滤功能
FileFilter接口方法：
`public boolean accept(File path)`：方法参数就是listFiles()方法获取到的文件或者目录的路径。如果方法返回true，表示需要此路径，否则此路径将被忽略。

- 遍历目录，获取所有的Java文件
```java
public static void main(String[] args){
    File dir = new File("d:\\demo");
    File[] files = dir.listFiles(new FileFilter() {
    @Override
    public boolean accept(File pathname) {
        //判断如果获取到的是目录，直接放行
        if(pathname.isDirectory())
        return true;
        //获取路径中的文件名，判断是否java结尾，是就返回true
        return pathname.getName().toLowerCase().endsWith("java");
      }
    });
    for(File file : files){
    	System.out.println(file);
    }
}
```


## 12.2 IO流顶层父类
| 类                   | 含义                                                    |
| -------------------- | ------------------------------------------------------- |
| java.io.OutputStream | 字节输出流顶层父类，抽象类，定义了写出数据方法write()。 |
| java.io.InputStream  | 字节输入流顶层父类，抽象类，定义了读取数据方法read()。  |
| java.io.Writer       | 字符输出流顶层父类，抽象类，定义了写出数据方法write()。 |
| java.io.Reader       | 字符输入流顶层父类，抽象类，定义了读取数据方法read()。  |


### 12.2.1 IO流中的异常处理
- try外声明变量，try内建立对象。
  - 目的是提升变量的作用域。
- finally中进行资源释放。
  - 进行流对象非空判断。
  - 如果有多个流对象，单独进行释放


## 12.3 字节流
### 12.3.1 字节输出流OutputStream
`java.io.OutputStream `抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。

- `public void close()` ：关闭此输出流并释放与此流相关联的任何系统资源。  
- `public void write(byte[] b)`：将 b.length字节从指定的字节数组写入此输出流。  
- `public void write(byte[] b, int off, int len)` ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 
- `public abstract void write(int b)` ：将指定的字节输出流。

注意：close方法，当完成流的操作时，必须调用此方法，释放系统资源。

#### FileOutputStream类
`java.io.FileOutputStream `类是文件输出流，用于将数据写出到文件。
- 构造方法
    - `public FileOutputStream(File file)`：创建文件输出流以写入由指定的 File对象表示的文件。 
    - `public FileOutputStream(String name)`： 创建文件输出流以指定的名称写入文件。 
- 写出字节数据
    - `write(int b)` 方法，每次可以写出一个字节数据。
    - `write(byte[] b)`，每次可以写出数组中的数据。
    - `write(byte[] b, int off, int len)` ,每次写出从off索引开始，len表示写出的个字节个数。
- 数据追加续写
    - `public FileOutputStream(File file, boolean append)`： 创建文件输出流以写入由指定的 File对象表示的文件。  
    - `public FileOutputStream(String name, boolean append)`： 创建文件输出流以指定的名称写入文件。

## 12.3.2 字节输入流InputStream
`java.io.InputStream `抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。

- `public void close()` ：关闭此输入流并释放与此流相关联的任何系统资源。    
- `public abstract int read()`： 从输入流读取数据的下一个字节。 
- `public int read(byte[] b)`： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。

#### FileInputStream类
`java.io.FileInputStream `类是文件输入流，从文件中读取字节。
- 构造方法
    - `FileInputStream(File file)`： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 
    - `FileInputStream(String name)`： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。
- 读取字节数据
    - `read`方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回`-1`。
    - `read(byte[] b)`，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回`-1`。

## 12.4 字符流
### 12.4.1 字符输入流Reader
`java.io.Reader`抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。

- `public void close()` ：关闭此流并释放与此流相关联的任何系统资源。    
- `public int read()`： 从输入流读取一个字符。 
- `public int read(char[] cbuf)`： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。

#### FileReader类
`java.io.FileReader `类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。
- 构造方法
    - `FileReader(File file)`： 创建一个新的 FileReader ，给定要读取的File对象。   
    - `FileReader(String fileName)`： 创建一个新的 FileReader ，给定要读取的文件的名称。  

- 读取字符数据
    - `read`方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回`-1`。
    - `read(char[] cbuf)`，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回`-1`。

### 12.4.2 字符输出流Writer
`java.io.Writer `抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。

- `public abstract void close()` ：关闭此输出流并释放与此流相关联的任何系统资源。  
- `public abstract void flush() ` ：刷新此输出流并强制任何缓冲的输出字符被写出。  
- `public void write(int c)` ：写出一个字符。
- `public void write(char[] cbuf)`：将 b.length字符从指定的字符数组写出此输出流。  
- `public abstract void write(char[] b, int off, int len)` ：从指定的字符数组写出 len字符，从偏移量 off开始输出到此输出流。  
- `public void write(String str)` ：写出一个字符串。

#### FileWriter类
`java.io.FileWriter `类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。

- 构造方法
    - `FileWriter(File file)`： 创建一个新的 FileWriter，给定要读取的File对象。   
    - `FileWriter(String fileName)`： 创建一个新的 FileWriter，给定要读取的文件的名称。

- 写出数据
    - `write(int b)` 方法，每次可以写出一个字符数据。
    - `write(char[] cbuf)` 和 `write(char[] cbuf, int off, int len)` ，每次可以写出字符数组中的数据。
    - `write(String str)` 和 `write(String str, int off, int len)` ，每次可以写出字符串中的数据。
    - 

- 关闭和刷新
    - `flush` ：刷新缓冲区，流对象可以继续使用。
    - `close` ：关闭流，释放系统资源。关闭前会刷新缓冲区。

## 12.5 属性集Properties类
`java.util.Properties ` 继承于` Hashtable` ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，`System.getProperties` 方法就是返回一个`Properties`对象。
唯一一个能够和IO流直接 结合使用的集合。
- 构造方法
    - `public Properties()` :创建一个空的属性列表。

- 基本的存储方法
    - `public Object setProperty(String key, String value)` ： 保存一对属性。  
    - `public String getProperty(String key) ` ：使用此属性列表中指定的键搜索属性值。
    - `public Set<String> stringPropertyNames() ` ：所有键的名称的集合。

- 与流相关的方法
    - `public void load(InputStream inStream)`： 从字节输入流中读取键值对。 


## 12.6 缓冲流
缓冲流,也叫高效流，是对4个基本的`FileXxx`流的增强，所以也是4个流，按照数据类型分类：
- **字节缓冲流**：`BufferedInputStream`，`BufferedOutputStream` 
- **字符缓冲流**：`BufferedReader`，`BufferedWriter`

缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。

### 12.6.1 字节缓冲流
- 构造方法
    - `public BufferedInputStream(InputStream in)` ：创建一个 新的缓冲输入流。 
    -  `public BufferedOutputStream(OutputStream out)`：创建一个新的缓冲输出流。
```java
// 创建字节缓冲输入流
BufferedInputStream bis = new BufferedInputStream(new FileInputStream("bis.txt"));
// 创建字节缓冲输出流
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("bos.txt"));
```

### 12.6.2 字符缓冲流
- 构造方法
    - `public BufferedReader(Reader in)` ：创建一个 新的缓冲输入流。 
    - `public BufferedWriter(Writer out)`： 创建一个新的缓冲输出流。
```java
// 创建字符缓冲输入流
BufferedReader br = new BufferedReader(new FileReader("br.txt"));
// 创建字符缓冲输出流
BufferedWriter bw = new BufferedWriter(new FileWriter("bw.txt"));
```
- 特有方法
    - BufferedReader：`public String readLine()`: 读一行文字。 
    - BufferedWriter：`public void newLine()`: 写一行行分隔符,由系统属性定义符号。
```java
public class BufferedReaderDemo {
    public static void main(String[] args) throws IOException {
      	 // 创建流对象
        BufferedReader br = new BufferedReader(new FileReader("in.txt"));
		// 定义字符串,保存读取的一行文字
        String line  = null;
      	// 循环读取,读取到最后返回null
        while ((line = br.readLine())!=null) {
            System.out.print(line);
            System.out.println("------");
        }
		// 释放资源
        br.close();
    }
}
```

## 12.7 转换流

### 12.7.1 InputStreamReader类
转换流`java.io.InputStreamReader`，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 

- 构造方法
    - `InputStreamReader(InputStream in)`: 创建一个使用默认字符集的字符流。 
    - `InputStreamReader(InputStream in, String charsetName)`: 创建一个指定字符集的字符流。
构造举例
```java
InputStreamReader isr = new InputStreamReader(new FileInputStream("in.txt"));
InputStreamReader isr2 = new InputStreamReader(new FileInputStream("in.txt") , "GBK");
```

### 12.7.2 OutputStreamWriter类

- 构造方法
转换流`java.io.OutputStreamWriter` ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 
    - `OutputStreamWriter(OutputStream in)`: 创建一个使用默认字符集的字符流。 
    - `OutputStreamWriter(OutputStream in, String charsetName)`: 创建一个指定字符集的字符流。

- 构造举例
```java
OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream("out.txt"));
OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream("out.txt") , "GBK");
```

## 12.8 序列化
Java 提供了一种对象**序列化**的机制。用一个字节序列可以表示一个对象，该字节序列包含该`对象的数据`、`对象的类型`和`对象中存储的属性`等信息。字节序列写出到文件之后，相当于文件中**持久保存**了一个对象的信息。 

反之，该字节序列还可以从文件中读取回来，重构对象，对它进行**反序列化**。`对象的数据`、`对象的类型`和`对象中存储的数据`信息，都可以用来在内存中创建对象。

### 12.8.1 ObjectOutputStream类
`java.io.ObjectOutputStream ` 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。

- 构造方法
    -`public ObjectOutputStream(OutputStream out) `： 创建一个指定OutputStream的ObjectOutputStream。

构造举例
```java
FileOutputStream fileOut = new FileOutputStream("employee.txt");
ObjectOutputStream out = new ObjectOutputStream(fileOut);
```
- 序列化操作
    - 该类必须实现`java.io.Serializable ` 接口，`Serializable` 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出`NotSerializableException` 。
    - 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用`transient` 关键字修饰。
举例
```java
public class Employee implements java.io.Serializable {
    public String name;
    public String address;
    public transient int age; // transient瞬态修饰成员,不会被序列化
    public void addressCheck() {
      	System.out.println("Address  check : " + name + " -- " + address);
    }
}
```
- 写出对象方法
    - `public final void writeObject (Object obj)` : 将指定的对象写出。

### 12.8.2 ObjectInputStream类
ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象.

- 构造方法
    - `public ObjectInputStream(InputStream in) `： 创建一个指定InputStream的ObjectInputStream。

- 反序列化操作1
如果能找到一个对象的class文件，我们可以进行反序列化操作，调用`ObjectInputStream`读取对象的方法：
    - `public final Object readObject ()` : 读取一个对象。
```java
            Employee e = null;
            // 创建反序列化流
            FileInputStream fileIn = new FileInputStream("employee.txt");
            ObjectInputStream in = new ObjectInputStream(fileIn);
            // 读取一个对象
            e = (Employee) in.readObject();
            // 释放资源
            in.close();
            fileIn.close();
```
对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 `ClassNotFoundException` 异常。

- 反序列化操作2
    -当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个`InvalidClassException`异常。
    - `Serializable` 接口给需要序列化的类，提供了一个序列版本号。`serialVersionUID` 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。
```java
public class Employee implements java.io.Serializable {
     // 加入序列版本号
     private static final long serialVersionUID = 1L;
     public String name;
     public String address;
     // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.
     public int eid; 

     public void addressCheck() {
         System.out.println("Address  check : " + name + " -- " + address);
     }
}
```

## 12.9 打印流与工具类
### 12.9.1 打印流PrintStream类
平时我们在控制台打印输出，是调用`print`方法和`println`方法完成的，这两个方法都来自于`java.io.PrintStream`类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。
- 构造方法
    - `public PrintStream(String fileName)  `： 使用指定的文件名创建一个新的打印流。
```java
public class PrintDemo {
    public static void main(String[] args) throws IOException {
		// 调用系统的打印流,控制台直接输出97
        System.out.println(97);
      
		// 创建打印流,指定文件的名称
        PrintStream ps = new PrintStream("ps.txt");
      	
      	// 设置系统的打印流流向,输出到ps.txt
        System.setOut(ps);
      	// 调用系统的打印流,ps.txt中输出97
        System.out.println(97);
    }
}
```

### 12.9.2 IO工具类 commonsIO
- 添加第三方工具包
    - 在module下创建文件夹lib
    - 将jar包文件复制到lib文件夹中
    - lib文件夹上按鼠标右键，选择`Add as Library`
        - level选项：选择module

使用：
- IOUtils类
  - 静态方法：IOUtils.copy(InputStream in,OutputStream out)传递字节流，实现文件复制。
  - 静态方法：IOUtils.closeQuietly(任意流对象)悄悄的释放资源，自动处理close()方法抛出的异常。
- FileUtils类
  - 静态方法：FileUtils.copyDirectoryToDirectory(File src,File dest);传递File类型的目录，进行整个目录的复制，自动进行递归遍历。
  - 静态方法：writeStringToFile(File file,String str)写字符串到文本文件中。
  - 静态方法：readFileToString(File file)读取文本文件，返回字符串。


# 13 泛型
泛型：可以在类或方法中预支地使用未知的类型。
## 13.1 使用泛型的好处
- 将运行时期的ClassCastException，转移到了编译时期变成了编译失败。
- 避免了类型强转的麻烦。

## 13.2 泛型的定义和使用
定义
```java
修饰符 class 类名<代表泛型的变量> {  }
修饰符 interface接口名<代表泛型的变量> {  }
修饰符 <代表泛型的变量> 返回值类型 方法名(参数){  }
```
使用
```java
//类：在创建对象使确定
ArrayList<Integer> list = new ArrayList<Integer>();
//方法：在调用方法时确定
mm.show("aaa");
mm.show(123);
/*接口：1.定义类时确定泛型的类型/
2.始终不确定泛型的类型，直到创建对象时，确定泛型的类型*/
```

## 13.3 泛型通配符
- 泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。
- 通配符高级使用----受限泛型
    - 泛型的上限：
    - 格式： `类型名称 <? extends 类 > 对象名称`
    - 意义： `只能接收该类型及其子类`
    - 泛型的下限：
    - 格式： `类型名称 <? super 类 > 对象名称`
    - 意义： `只能接收该类型及其父类型`

# 14 JDK8新特性
## 14.1 Lambda表达式
Lambda是一个**匿名函数**，可以理解为一段可以传递的代码。Lambda的优点:简化匿名内部类的使用，语法更加简单。

### 14.1.1 Lambda的格式
Lambda省去面向对象的条条框框，格式由3个部分组成：

- 一些参数
- 一个箭头
- 一段代码

Lambda表达式的**标准格式**为：

```java
(参数类型 参数名称) -> { 代码语句 }
```

**格式说明：**

* 小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。
* `->`是新引入的语法格式，代表指向动作。
* 大括号内的语法与传统方法体要求基本一致。

**匿名内部类与lambda对比:**

```java
new Thread(new Runnable() {
			@Override
			public void run() {
				System.out.println("多线程任务执行！");
			}
}).start();
```

```java
() -> System.out.println("多线程任务执行！")
```

- 前面的一对小括号即`run`方法的参数（无），代表不需要任何条件；
- 中间的一个箭头代表将前面的参数传递给后面的代码；
- 后面的输出语句即业务逻辑代码。

### 14.1.2省略格式
**省略规则**

在Lambda标准格式的基础上，使用省略写法的规则为：
1. 小括号内参数的类型可以省略；
2. 如果小括号内**有且仅有一个参**，则小括号可以省略；
3. 如果大括号内**有且仅有一个语句**，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。

> 备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。

```java
Runnable接口简化:
1. () -> System.out.println("多线程任务执行！")
Comparator接口简化:
2. Arrays.sort(array, (a, b) -> a.getAge() - b.getAge());
```

**以后我们调用方法时,看到参数是接口就可以考虑使用Lambda表达式,Lambda表达式相当于是对接口中抽象方法的重写.**

### 14.1.3 Lambda的前提条件

Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有两个问题需要特别注意：

1. 使用Lambda必须具有接口，且要求**接口中有且仅有一个抽象方法**。
   无论是JDK内置的`Runnable`、`Comparator`接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。
2. 使用Lambda必须具有接口作为方法参数。
   也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。

## 14.2 函数式接口
函数式接口在Java中是指：**有且仅有一个抽象方法的接口**。

函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。

### 14.2.1 格式
只要确保接口中有且仅有一个抽象方法即可：
```java
修饰符 interface 接口名称 {
    public abstract 返回值类型 方法名称(可选参数信息);
    // 其他非抽象方法内容
}
```

### 14.2.2 常用函数式接口
我们知道使用Lambda表达式的前提是需要有函数式接口。而Lambda使用时不关心接口名，抽象方法名，只关心抽 象方法的参数列表和返回值类型。因此为了让我们使用Lambda方便，JDK提供了大量常用的函数式接口。它们主要在`java.util.function`包中被提供.
#### Supplier接口

`java.util.function.Supplier<T>`接口，它意味着"供给" , 对应的Lambda表达式需要“**对外提供**”一个符合泛型类型的对象数据。

**抽象方法 : get** 

仅包含一个无参的方法：`T get()`。用来获取一个泛型参数指定类型的对象数据。

#### Consumer接口

`java.util.function.Consumer<T>`接口则正好相反，它不是生产一个数据，而是**消费**一个数据，其数据类型由泛型参数决定。

**抽象方法：accept**

`Consumer`接口中包含抽象方法`void accept(T t)`，意为消费一个指定泛型的数据。

#### Function接口

`java.util.function.Function<T,R>`接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。有进有出，所以称为“函数Function”。

**抽象方法：apply**

`Function`接口中最主要的抽象方法为：`R apply(T t)`，根据类型T的参数获取类型R的结果。使用的场景例如：将`String`类型转换为`Integer`类型。

#### Predicate接口

有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用`java.util.function.Predicate<T>`接口。

**抽象方法：test**

`Predicate`接口中包含一个抽象方法：`boolean  test(T t) `。

## 14.3 方法引用
### 14.3.1 方法引用说明
**符号表示 :** `::`
**符号说明 :**  双冒号为方法引用运算符，而它所在的表达式被称为**方法引用**。
**应用场景 : **如果Lambda要表达的函数方案 , 已经存在于某个方法的实现中，那么则可以使用方法引用。
> 如上例中，System.out对象中有个println(String)方法 , 恰好就是我们所需要的 , 那么对于Consumer接口作为参数，对比下面两种写法，完全等效：
>
> - Lambda表达式写法：s -> System.out.println(s);
>   拿到参数之后经Lambda之手，继而传递给System.out.println方法去处理。
> - 方法引用写法：System.out::println
>   直接让System.out中的println方法来取代Lambda。

推导与省略 :  如果使用Lambda，那么根据“**可推导就是可省略**”的原则，无需指定参数类型，也无需指定的重载形式——它们都将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。函数式接口是Lambda的基础，而方法引用是Lambda的简化形式。

### 14.3.2 扩展的引用方式
- 对象名--引用成员方法
- 类名--引用静态方法
- 类--构造引用
- 数组--构造引用

## 14.4 第四章 Stream流
Stream流式思想类似于工厂车间的“**生产流水线**”，Stream流不是一种数据结构，不保存数据，而是对数据进行加工 处理。Stream可以看作是流水线上的一个工序。在流水线上，通过多个工序让一个原材料加工成一个商品。

### 14.4.1 获取流方式

`java.util.stream.Stream<T>`是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）

获取一个流非常简单，有以下几种常用的方式：

- 所有的`Collection`集合都可以通过`stream`默认方法获取流；
- `Stream`接口的静态方法`of`可以获取数组对应的流。
```java
//根据Collection获取流
List<String> list = new ArrayList<>();
Stream<String> stream1 = list.stream();

根据数组获取流
String[] array = { "张无忌", "张翠山", "张三丰", "张一元" };
Stream<String> stream = Stream.of(array);
```

### 14.4.2 常用方法

流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：

- **终结方法**：返回值类型不再是`Stream`接口自身类型的方法，因此不再支持类似`StringBuilder`那样的链式调用。本小节中，终结方法包括`count`和`forEach`方法。
- **非终结方法**：返回值类型仍然是`Stream`接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为非终结方法。）

| 方法名  | 方法作用   | 方法种类 | 是否支持链式调用 |
| ------- | ---------- | -------- | ---------------- |
| count   | 统计个数   | 终结     | 否               |
| forEach | 逐一处理   | 终结     | 否               |
| filter  | 过滤       | 函数拼接 | 是               |
| limit   | 取用前几个 | 函数拼接 | 是               |
| skip    | 跳过前几个 | 函数拼接 | 是               |
| concat  | 组合       | 函数拼接 | 是               |
| distinct    | 去重 | 函数拼接 | 是               |
| map  | 映射       | 函数拼接 | 是               |


```java
public class Demo23StreamNames {
    public static void main(String[] args) {
        List<String> one = new ArrayList<>();
        // ...
        List<String> two = new ArrayList<>();
        // ...
        // 第一个队伍只要名字为3个字的成员姓名；
        // 第一个队伍筛选之后只要前3个人；
        Stream<String> streamOne = one.stream().filter(s -> s.length() == 3).limit(3);

        // 第二个队伍只要姓张的成员姓名；
        // 第二个队伍筛选之后不要前2个人；
        Stream<String> streamTwo = two.stream().filter(s -> s.startsWith("张")).skip(2);

        // 将两个队伍合并为一个队伍；
        // 根据姓名创建Person对象；
        // 打印整个队伍的Person对象信息。
        Stream.concat(streamOne, streamTwo).forEach(s->System.out.println(s));
    }
}
```

### 14.4.3 Stream流中的结果到集合中
Stream流提供 collect方法，其参数需要一个 java.util.stream.Collector<T,A, R>接口对象来指定收集到哪 种集合中。java.util.stream.Collectors 类提供一些方法，可以作为  Collector`接口的实例： 

- public static <T> Collector<T, ?, List<T>> toList()：转换为 List集合。 
- public static <T> Collector<T, ?, Set<T>> toSet()：转换为 Set集合。
```java
        List<String> list = stream.collect(Collectors.toList());
        //转换为set集合
        Set<String> set = stream.collect(Collectors.toSet());
        //转换为ArrayList集合
        ArrayList<String> arrayList = stream.collect(Collectors.toCollection(ArrayList::new));
```

### 14.4.4 Stream流中的结果到数组中
Stream提供 toArray方法来将结果放到一个数组中，返回值类型是Object[]的：

```java
Object[] toArray();
```
其使用场景如：

```java
public class Test {
    public static void main(String[] args) {
        Stream<String> stream = Stream.of("aa", "bb", "cc");

        Object[] objects = stream.toArray();
        System.out.println(Arrays.toString(objects));

        String[] strings = stream.toArray(String[]::new);
        System.out.println(Arrays.toString(strings));
    }
}
```

# 15 网络编程
## 15.1 软件结构
- C/S结构：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。
- B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。

## 15.2 网络通信协议
- 网络通信协议：通信协议是对计算机必须遵守的规则，只有遵守这些规则，计算机之间才能进行通信。
- TCP/IP协议：传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。

## 15.3 网络编程三要素
- 协议：计算机网络通信必须遵守的规则。
- IP地址：指互联网协议地址（Internet Protocol Address）。
- 端口号：用两个字节表示的整数，它的取值范围是0~65535。

### 15.3.1 InetAddress
JDK中提供了一个InetAdderss类，该类用于封装一个IP地址，并提供了一系列与IP地址相关的方法，下表中列出了InetAddress类的一些常用方法.

| 方法                                      | 描述                                     |
| ----------------------------------------- | ---------------------------------------- |
| static InetAddress getByName(String host) | 在给定主机名的情况下确定主机的 IP 地址。 |
| static InetAddress getLocalHost()         | 返回本地主机                             |
| public String getHostName()               | 获取此 IP 地址的主机名。                 |
| public String getHostAddress()            | 返回 IP 地址字符串（以文本表现形式）。   |

## 15.4 通信协议
在介绍TCP/IP结构时，提到传输层的两个重要的高级协议，分别是UDP和TCP，其中UDP是User Datagram Protocol的简称，称为用户数据报协议，TCP是Transmission Control Protocol的简称，称为传输控制协议。

### 15.4.1 UDP协议
UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。
由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。
但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。

### 15.4.2 TCP协议

TCP传输控制协议 (Transmission Control Protocol)。TCP协议是**面向连接**的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。
- 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。
  - 第一次握手，客户端向服务器端发出连接请求，等待服务器确认。
  - 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。
  - 第三次握手，客户端再次向服务器端发送确认信息，确认连接。
由于TCP协议的面向连接特性，它可以保证传输数据的安全性，所以是一个被广泛采用的协议，例如在下载文件时，如果数据接收不完整，将会导致文件数据丢失而不能被打开，因此，下载文件时必须采用TCP协议。

## 15.5 UDP通信
### 15.5.1 DatagramPacket
UDP是一种面向无连接的协议，在通信时发送端和接收端不用建立连接。UDP通信的过程就像是货运公司在两个码头间发送货物一样。在码头发送和接收货物时都需要使用集装箱来装载货物，UDP通信也是一样，发送和接收的数据也需要使用“集装箱”进行打包，为此JDK中提供了一个DatagramPacket类，该类的实例对象就相当于一个集装箱，用于封装UDP通信中发送或者接收的数据。

在创建发送端和接收端的DatagramPacket对象时，使用的构造方法有所不同，接收端的构造方法只需要接收一个字节数组来存放接收到的数据，而发送端的构造方法不但要接收存放了发送数据的字节数组，还需要指定发送端IP地址。
```
DatagramPacket(byte[] buf, int length)  构造 DatagramPacket，用来接收长度为 length 的数据包。
```

使用该构造方法在创建DatagramPacket对象时，指定了封装数据的字节数组和数据的大小，没有指定IP地址和端口号。很明显，这样的对象只能用于接收端，不能用于发送端。因为发送端一定要明确指出数据的目的地(ip地址和端口号)，而接收端不需要明确知道数据的来源，只需要接收到数据即可。

```java
DatagramPacket(byte[] buf, int length, InetAddress address, int port) 
构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。
```

使用该构造方法在创建DatagramPacket对象时，不仅指定了封装数据的字节数组和数据的大小，还指定了数据包的目标IP地址（addr）和端口号（port）。该对象通常用于发送端，因为在发送数据时必须指定接收端的IP地址和端口号，就好像发送货物的集装箱上面必须标明接收人的地址一样。
DatagramPacket类中的常用方法，如下表所示。

| 方法                            | 描述                               |
| ------------------------------- | ---------------------------------- |
| public InetAddress getAddress() | 返回某台机器的 IP 地址             |
| public int getPort()            | 返回某台远程主机的端口号           |
| public byte[] getData()         | 返回数据缓冲区                     |
| public int getLength()          | 返回将要发送或接收到的数据的长度。 |

### 15.5.2 DatagramSocket

DatagramPacket数据包的作用就如同是“集装箱”，可以将发送端或者接收端的数据封装起来。然而运输货物只有“集装箱”是不够的，还需要有码头。在程序中需要实现通信只有DatagramPacket数据包也同样不行，为此JDK中提供的一个DatagramSocket类。DatagramSocket类的作用就类似于码头，使用这个类的实例对象就可以发送和接收DatagramPacket数据包，发送数据的过程如下图所示。

在创建发送端和接收端的DatagramSocket对象时，使用的构造方法也有所不同，下面对DatagramSocket类中常用的构造方法进行讲解。

```java
DatagramSocket()  构造数据报套接字并将其绑定到本地主机上任何可用的端口。
```

该构造方法用于创建发送端的DatagramSocket对象，在创建DatagramSocket对象时，并没有指定端口号，此时，系统会分配一个没有被其它网络程序所使用的端口号。

```java
DatagramSocket(int port) 创建数据报套接字并将其绑定到本地主机上的指定端口。
```

该构造方法既可用于**创建接收端的DatagramSocket对象，又可以创建发送端的DatagramSocket对象**，在创建接收端的DatagramSocket对象时，必须要指定一个端口号，这样就可以监听指定的端口。

DatagramSocket类中的常用方法：

```java
public void send(DatagramPacket p) 发送数据报包
```

```java
public void receive(DatagramPacket p) 接收数据报包
```

### 15.5.3 案例
要实现UDP通信需要创建一个发送端程序和一个接收端程序，很明显，在通信时只有接收端程序先运行，才能避免因发送端发送的数据无法接收，而造成数据丢失。因此，首先需要来完成接收端程序的编写。

**UDP完成数据的发送**

```java
/*
 * 发送端
 * 1,创建DatagramSocket对象
 * 2，创建DatagramPacket对象，并封装数据
 * 3，发送数据
 * 4，释放流资源
 */
public class UDPSend {
    public static void main(String[] args) throws IOException {
        //1,创建DatagramSocket对象
        DatagramSocket sendSocket = new DatagramSocket();
        //2，创建DatagramPacket对象，并封装数据
        //public DatagramPacket(byte[] buf, int length, InetAddress address,  int port)
        //构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。
        byte[] buffer = "hello,UDP".getBytes();
        DatagramPacket dp = new DatagramPacket(buffer, buffer.length, InetAddress.getByName("192.168.75.58"), 12306);
        //3，发送数据
        //public void send(DatagramPacket p) 从此套接字发送数据报包
        sendSocket.send(dp);
        //4，释放流资源
        sendSocket.close();
    }
}

```

**UDP接收端**

```java
/*
 * UDP接收端
 *
 * 1,创建DatagramSocket对象
 * 2,创建DatagramPacket对象
 * 3,接收数据存储到DatagramPacket对象中
 * 4,获取DatagramPacket对象的内容
 * 5,释放流资源
 */
public class UDPReceive {
    public static void main(String[] args) throws IOException {
        //1,创建DatagramSocket对象,并指定端口号
        DatagramSocket receiveSocket = new DatagramSocket(12306);
        //2,创建DatagramPacket对象, 创建一个空的仓库
        byte[] buffer = new byte[1024];
        DatagramPacket dp = new DatagramPacket(buffer, 1024);
        //3,接收数据存储到DatagramPacket对象中
        receiveSocket.receive(dp);
        //4,获取DatagramPacket对象的内容
        //谁发来的数据  getAddress()
        InetAddress ipAddress = dp.getAddress();
        String ip = ipAddress.getHostAddress();//获取到了IP地址
        //发来了什么数据  getData()
        byte[] data = dp.getData();
        //发来了多少数据 getLenth()
        int length = dp.getLength();
        //显示收到的数据
        String dataStr = new String(data,0,length);
        System.out.println("IP地址："+ip+ "数据是"+ dataStr);
        //5,释放流资源
        receiveSocket.close();
    }
}
```

## 15.6 TCP通信协议
TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。

**两端通信时步骤：**

1. 服务端程序，需要事先启动，等待客户端的连接。
2. 客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。

**在Java中，提供了两个类用于实现TCP通信程序：**

- 客户端：`java.net.Socket` 类表示。创建`Socket`对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。
- 服务端：`java.net.ServerSocket` 类表示。创建`ServerSocket`对象，相当于开启一个服务，并等待客户端的连接。

### 15.6.1 Socket类  
`Socket` 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。
构造方法
- `public Socket(String host, int port)` :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。 

```java
Socket client = new Socket("127.0.0.1", 6666);
```

成员方法
- `public InputStream getInputStream()` ： 返回此套接字的输入流。
  - 如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。
  - 关闭生成的InputStream也将关闭相关的Socket。
- `public OutputStream getOutputStream()` ： 返回此套接字的输出流。
  - 如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。
  - 关闭生成的OutputStream也将关闭相关的Socket。
- `public void close()` ：关闭此套接字。
  - 一旦一个socket被关闭，它不可再使用。
  - 关闭此socket也将关闭相关的InputStream和OutputStream 。 
- `public void shutdownOutput()` ： 禁用此套接字的输出流。   
  - 任何先前写出的数据将被发送，随后终止输出流。 

### 15.6.2 ServerSocket类

`ServerSocket`类：这个类实现了服务器套接字，该对象等待通过网络的请求。

构造方法
- `public ServerSocket(int port)` ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。

```
ServerSocket server = new ServerSocket(6666);
```

成员方法
- `public Socket accept()` ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。

### 15.6.3 简单的TCP网络程序

**TCP通信分析**
1. 【服务端】启动,创建ServerSocket对象，等待连接。
2. 【客户端】启动,创建Socket对象，请求连接。
3. 【服务端】接收连接,调用accept方法，并返回一个Socket对象。
4. 【客户端】Socket对象，获取OutputStream，向服务端写出数据。
5. 【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。
6. 【服务端】Socket对象，获取OutputStream，向客户端回写数据。
7. 【客户端】Scoket对象，获取InputStream，解析回写数据。
8. 【客户端】释放资源，断开连接。

#### 文件上传案例
**文件上传分析**
1. 【客户端】输入流，从硬盘读取文件数据到程序中。
2. 【客户端】输出流，写出文件数据到服务端。
3. 【服务端】输入流，读取文件数据到服务端程序。
4. 【服务端】输出流，写出文件数据到服务器硬盘中。
5. 【服务端】获取输出流，回写数据。
6. 【客户端】获取输入流，解析回写数据。

文件上传客户端实现
```java
public static void main(String[] args) throws IOException {
    // 1.创建流对象
    // 1.1 创建输入流,读取本地文件
    BufferedInputStream bis = new BufferedInputStream(new FileInputStream("test.jpg"));
    // 1.2 创建输出流,写到服务端
    Socket socket = new Socket("localhost", 6666);
    BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());

    //2.写出数据.
    byte[] b  = new byte[1024 * 8 ];
    int len ;
    while (( len  = bis.read(b))!=-1) {
    	bos.write(b, 0, len);
    }
    // 关闭输出流,通知服务端,写出数据完毕
    socket.shutdownOutput();
    System.out.println("文件发送完毕");
    // 3. =====解析回写============
    InputStream in = socket.getInputStream();
    byte[] back = new byte[20];
    in.read(back);
    System.out.println(new String(back));
    in.close();
    
    // 4.释放资源
    socket.close();
    bis.close();
}
```

文件上传服务器
利用线程池进行优化
```java
public static void main(String[] args)  throws IOException{
    System.out.println("服务器 启动.....  ");
    ServerSocket serverSocket = new ServerSocket(6666);
	//创建10个线程的线程池
    ExecutorService executorService = Executors.newFixedThreadPool(10);
    
    while (true) {
        Socket accept = serverSocket.accept();
        //提交线程执行的任务
        executorService.submit(()->{
            try{

            BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());
            FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + ".jpg");
            BufferedOutputStream bos = new BufferedOutputStream(fis);
            byte[] b = new byte[1024 * 8];
            int len;
            while ((len = bis.read(b)) != -1) {
            bos.write(b, 0, len);
            }
            System.out.println("back ........");
            OutputStream out = accept.getOutputStream();
            out.write("上传成功".getBytes());
            out.close();
            bos.close();
            bis.close();
            accept.close();
            System.out.println("文件上传已保存");
            } catch (IOException e) {
            	e.printStackTrace();
            }
        });
    }
}
```

# 16 枚举
枚举是JDK1.5新增的引用数据类型，和类，接口是一个级别的，定义枚举的关键字为`enum`。
`java.lang.Enum`类，是所有枚举的父类。
枚举的本质就是一个类的多个对象。

## 16.1 枚举的定义

- 格式：`public enmu 枚举名{}`
- 枚举常量定义：
  - 枚举中的常量名字大写，多个常量之间逗号分开，最后一个常量可以写分号，也可以不写。每一个常量，都表示这个类的对象。修饰符为`public static final`。
  - 枚举中有默认的无参数的private修饰的构造方法，如果手写构造方法，也必须是私有修饰的。而且构造方法必须写在常量的后面，这时最后一个常量就必须要写分号。

```java
public enum  Color {
    //枚举的静态常量
    RED,GREEN,YELLOW
}
```

```java
public enum Color{
	//枚举静态常量，直接为变量color赋值
	RED("红色"),GREEN("绿色"),YELLOW("黄色");
	private String color;
	priate Color(String color){
		this.color = color ;
	}
    //省略get/set
}
```

## 16.2 枚举的使用
由于枚举的常量为静态修饰可以直接枚举名.调用
```java
public static void main(String[] args){
    MyEnum myEnum = MyEnum.GREEN;
    System.out.println(myEnum);
    System.out.println(myEnum.getName());
}
```

# 17 注解
注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。

**作用分类**：
- 编写文档：通过代码里标识的注解生成文档【例如，生成文档doc文档】
- 代码分析：通过代码里标识的注解对代码进行分析【例如，注解的反射】
- 编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【例如，Override】

## 17.1 自定义注解
### 17.1.1 定义格式
```java
元注解
public @interface 注解名称{
	属性列表;
}
```
注解本质上就是一个接口，该接口默认继承Annotation接口。

```java
public @interface MyAnno extends java.lang.annotation.Annotation {}
```
任何一个注解，都默认的继承Annotation接口。

### 17.1.2 注解的属性
1. **属性的作用**
   - 可以让用户在使用注解时传递参数，让注解的功能更加强大。
2. **属性的格式**
   - **格式1：数据类型 属性名();**
   - **格式2：数据类型 属性名() default 默认值;**
3. **属性定义示例**
   ```java
   public @interface Student {
     String name(); // 姓名
     int age() default 18; // 年龄
     String gender() default "男"; // 性别
   } 
   // 该注解就有了三个属性：name，age，gender
   ```
4. **属性适用的数据类型**
   - 八种基本数据类型（**int,float,boolean,byte,double,char,long,short**)。
   - String类型，Class类型，枚举类型，注解类型。
   - 以上所有类型的一维数组。

## 17.2 使用自定义注解
在程序中使用(解析)注解的步骤（获取注解中定义的属性值）：
1. 获取注解定义的位置的对象  （Class，Method,Field）
2. 获取指定的注解 `getAnnotation(Class)`
3. 调用注解中的抽象方法获取配置的属性值

使用格式:

@注解名(属性名=属性值,属性名=属性值,属性名=属性值...)

### 17.2.1 定义注解
1. **定义一个注解：Book**
   - 包含属性：String value()   书名
   - 包含属性：double price()  价格，默认值为 100
   - 包含属性：String[] authors() 多位作者    
2. **代码实现**

```java
public @interface Book {
    // 书名
    String value();
    // 价格
    double price() default 100;
    // 多位作者
    String[] authors();
}
```
### 17.2.2 使用注解
```java
public class BookShelf {
  
    @Book(value = "西游记",price = 998,authors = {"吴承恩","白求恩"})
    public void showBook(){

    }
}
```
**使用注意事项**
- 如果属性有默认值，则使用注解的时候，这个属性可以不用赋值。
- 如果属性没有默认值，那么在使用注解时一定要给属性赋值。 

特殊属性value
- 当注解中只有一个属性且名称是value，在使用注解时给value属性赋值可以直接给属性值，无论value是单值元素还是数组类型。
- 如果注解中除了value属性还有其他属性，且至少有一个属性没有默认值，则在使用注解给属性赋值时，value属性名不能省略。

## 17.3 注解之元注解
默认情况下，注解可以用在任何地方，比如类，成员方法，构造方法，成员变量等地方。如果要限制注解的使用位置怎么办？那就要学习一个新的知识点：元注解。
- **@Target**
- **@Retention**

### 17.3.1 元注解之@Target
- **作用：指明此注解用在哪个位置，如果不写默认是任何地方都可以使用。**
  - 可选的参数值在枚举类**ElemenetType**中包括：

```properties
 TYPE： 用在类,接口上
 FIELD：用在成员变量上
 METHOD： 用在方法上
 PARAMETER：用在参数上
 CONSTRUCTOR：用在构造方法上
 LOCAL_VARIABLE：用在局部变量上
```

### 17.3.2 元注解之@Retention
- **作用：定义该注解的生命周期(有效范围)。**
  - 可选的参数值在枚举类型RetentionPolicy中包括

```properties
SOURCE：注解只存在于Java源代码中，编译生成的字节码文件中就不存在了。
CLASS：注解存在于Java源代码、编译以后的字节码文件中，运行的时候内存中没有，默认值。
RUNTIME：注解存在于Java源代码中、编译以后的字节码文件中、运行时内存中，程序可以通过反射获取该注解。
```

## 17.4 注解解析
通过Java技术获取注解数据的过程则称为注解解析。
### 17.4.1 与注解解析相关的接口
- **Annotation**：所有注解类型的公共接口，类似所有类的父类是Object。
- **AnnotatedElement**：定义了与注解解析相关的方法，常用方法以下四个：
```java
boolean isAnnotationPresent(Class annotationClass); 判断当前对象是否有指定的注解，有则返回true，否则返回false。
T getAnnotation(Class<T> annotationClass);  获得当前对象上指定的注解对象。
Annotation[] getAnnotations(); 获得当前对象及其从父类上继承的所有的注解对象。
Annotation[] getDeclaredAnnotations();获得当前对象上所有的注解对象，不包括父类的。
```
### 17.4.2 获取注解数据的原理
```
注解作用在那个成员上，就通过反射获得该成员的对象来得到它的注解。
```
- 如注解作用在方法上，就通过方法(Method)对象得到它的注解。
  ```java
   // 得到方法对象
   Method method = clazz.getDeclaredMethod("方法名"); 
   // 根据注解名得到方法上的注解对象
   Book book = method.getAnnotation(Book.class); 
  ```

- 如注解作用在类上，就通过Class对象得到它的注解。
  ```
  // 获得Class对象
  Class c = 类名.class;
  // 根据注解的Class获得使用在类上的注解对象
  Book book = c.getAnnotation(Book.class);
  ```

## 17.5 使用反射获取注解的数据
### 17.5.1 需求说明
1. 定义注解Book，要求如下：
   - 包含属性：String value()   书名
   - 包含属性：double price()  价格，默认值为 100
   - 包含属性：String[] authors() 多位作者  
   - 限制注解使用的位置：类和成员方法上
   - 指定注解的有效范围：RUNTIME
2. 定义BookStore类，在类和成员方法上使用Book注解
3. 定义TestAnnotation测试类获取Book注解上的数据

### 17.5.2 代码实现
**注解Book**

```java
@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface Book {
    // 书名
    String value();
    // 价格
    double price() default 100;
    // 作者
    String[] authors();
}
```
**BookStore类**
```java
@Book(value = "红楼梦",authors = "曹雪芹",price = 998)
public class BookStore {
}
```
**TestAnnotation类**
```java
public class TestAnnotation {
    public static void main(String[] args)  throws Exception{
        System.out.println("---------获取类上注解的数据----------");
        test();
    }

    /**
     * 获取BookStore类上使用的Book注解数据
     */
    public static void test(){
        // 获得BookStore类对应的Class对象
        Class c = BookStore.class;
        // 判断BookStore类是否使用了Book注解
        if(c.isAnnotationPresent(Book.class)) {
            // 根据注解Class对象获取注解对象
            Book book = (Book) c.getAnnotation(Book.class);
            // 输出book注解属性值
            System.out.println("书名：" + book.value());
            System.out.println("价格：" + book.price());
            System.out.println("作者：" + Arrays.toString(book.authors()));
        }
}
```
## 17.6 模拟Junit
### 17.6.1 Junit
Junit是一个Java语言的单元测试框架，属于白盒测试，简单理解为可以用于取代java的main方法。Junit属于第三方工具，需要导入jar包后使用。
#### Junit的使用

1. 编写测试类，简单理解Junit可以用于取代java的main方法。
2. 在测试类方法上添加注解 @Test。
3. @Test修饰的方法要求：public void 方法名() {…} ，方法名自定义建议test开头，没有参数。
4. 添加Junit库到lib文件夹中，然后进行jar包关联。
#### 常用注解
- @Test，用于修饰需要执行的测试方法。
- @Before，修饰的方法会在测试方法之前被自动执行。
- @After，修饰的方法会在测试方法执行之后自动被执行。

### 17.6.2 案例分析

1. 模拟Junit测试的注释@Test，首先需要编写自定义注解@MyTest，并添加元注解，保证自定义注解只能修饰方法，且在运行时可以获得。
2. 然后编写目标类（测试类），然后给目标方法（测试方法）使用 @MyTest注解，编写三个方法，其中两个加上@MyTest注解。
3. 最后编写调用类，使用main方法调用目标类，模拟Junit的运行，只要有@MyTest注释的方法都会运行。

**注解MyTest**
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyTest {
}
```
**目标类MyTestDemo**
```java
public class MyTestDemo {
    @MyTest
    public void test01(){
        System.out.println("test01");
    }

    public void test02(){
        System.out.println("test02");
    }

    @MyTest
    public void test03(){
        System.out.println("test03");
    }
}
```
**调用类TestMyTest**
```java
public class TestMyTest {
    public static void main(String[] args) throws  Exception{
        // 获得MyTestDemo类Class对象
        Class c = MyTestDemo.class;
        // 获得所有的成员方法对象
        Method[] methods = c.getMethods();
        // 创建MyTestDemo类对象
        Object obj = c.newInstance();
        // 遍历数组
        for (Method m:methods) {
            // 判断方法m上是否使用注解MyTest
            if(m.isAnnotationPresent(MyTest.class)){
                // 执行方法m
                m.invoke(obj);
            }
        }
    }
}
```

## 17.7 lombok
Lombok通过增加一些“处理程序”，可以让java变得简洁、快速。

Lombok能以注解形式来简化java代码，提高开发效率。开发中经常需要写的javabean，都需要花时间去添加相应的getter/setter，也许还要去写构造器、equals等方法，而且需要维护。

Lombok能通过注解的方式，在编译时自动为属性生成构造器、getter/setter、equals、hashcode、toString方法。出现的神奇就是在源码中没有getter和setter方法，但是在编译生成的字节码文件中有getter和setter方法。这样就省去了手动重建这些代码的麻烦，使代码看起来更简洁些。





# 18 反射
## 18.1 类的加载器
### 18.1.1 类的加载器时机

1. 创建类的实例。
2. 类的静态变量，或者为静态变量赋值。
3. 类的静态方法。
4. 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象。
5. 初始化某个类的子类。
6. 直接使用java.exe命令来运行某个主类。

以上6个情况，只要有1个出现，那么类的加载器就会将这个类的class文件加载到内存中，我们就可以使用这个类了。`java.lang.ClassLoader`：是类的加载器的父类。

### 18.1.2 引导类加载器

引导类加载器Bootstrap：是C++语言编写，负责加载JDK核心类库，核心类库位置\jdk\jre\lib\下的jar包。
由于引导类加载器器在JVM内部，开发人员是不能直接操作的。
```java
ClassLoader loader = String.class.getClassLoader();
```
程序的输出结果是null，C++编写的加载器，根本就不是Java中的类。

### 18.1.3 扩展类加载器
扩展类加载器ExtClassLoader：Java语言编写的类加载器，负责加载JDK扩展类库，类库位置\jdk\lib\ext\下的jar包。
```java
ClassLoader loader = DNSNameService.class.getClassLoader();
System.out.println(loader);
```

程序的输出结果是：sun.misc.Launcher$ExtClassLoader@45ee12a7，ExtClassLoader类继承URLClassLoader，URLClassLoader继承SecureClassLoader，SecureClassLoader继承ClassLoader。

### 18.1.4 应用类加载器
应用类加载器AppClassLoader：Java语言编写的类加载器，负责加载我们定义的类和第三方jar包中的类。
```java
ClassLoader loader = Test.class.getClassLoader();
System.out.println(loader);
```
程序的输出结果是：sun.misc.Launcher$AppClassLoader@18b4aac2，AppClassLoader继承URLClassLoader，URLClassLoader继承SecureClassLoader，SecureClassLoader继承ClassLoader。

### 18.1.5 类加载器的双亲委派
ClassLoader类定义了方法 `ClassLoader getParent()`：返回父类加载器。
```java
//获取自己定义类的加载器，结果为AppClassLoader
ClassLoader loader = Test.class.getClassLoader();
//获取AppClassLoader的父类加载器，结果为ExtClassLoader
System.out.println(loader.getParent());
//获取ExtClassLoader的父类加载器，结果为null
System.out.println(loader.getParent().getParent());
```

结论： AppClassLoader的父类加载器是ExtClassLoader，ExtClassLoader的父类加载器是Bootstrap。
**注意**：ExtClassLoader是AppClassLoader的父加载器，并不是父类，他们没有继承关系。

**双亲委派机制**：当AppClassLoader收到一个加载类的请求时，会先让他的父类加载器ExtClassLoader尝试加载，ExtClassLoader也会让他的父类加载器Bootstrap尝试加载，如果Bootstrap能加载，就加载该类。如果Bootstrap不能加载，则ExtClassLoader会进行加载，如果也不能加载，AppClassLoader会进行加载。

### 18.1.6 Class对象创建
当一个类的class文件被类加载器加载到内存后，类的加载器会创建出此class文件的对象。class文件的对象是Class类的对象，是反射技术的基石。

## 18.2 反射
### 18.2.1 反射概念
- 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码
- 反射：将java代码的各个组成部分封装为其他对象，可以在程序运行过程中操作这些对象，这就是java的反射机制，如下图。
- 反射的好处：
    - 可以在程序运行过程中，操作这些对象。
    - 可以解耦，提高程序的可扩展性。

### 18.2.2 获取Class对象的方式

| 获取class对象方式       | 作用                         | 应用场景                                                 |
| ----------------------- | ---------------------------- | -------------------------------------------------------- |
| Class.forName("全类名") | 通过指定的字符串路径获取     | 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 |
| 类名.class              | 通过类名的属性class获取      | 多用于参数的传递                                         |
| 对象.getClass()         | 通过对象的getClass()方法获取 | 多用于对象的获取字节码的方式                             |


### 18.2.3 反射获取构造方法

#### Class类中与Constructor相关方法
```java
1. Constructor[] getConstructors() 
   	获取所有的public修饰的构造方法
2. Constructor getConstructor(Class... parameterTypes) 
    根据参数类型获取构造方法对象，只能获得public修饰的构造方法。
	如果不存在对应的构造方法，则会抛出 java.lang.NoSuchMethodException 异常。
	参数是可变参数,调用此方法时,可以不写参数,获取的空参构造
                可以写参数,给定的参数必须是Class对象
                    比如:
						参数 String name,int age
                        调用此方法: String.class,int.class 
```
#### Constructor类中常用方法
```java
1. T newInstance(Object... initargs) 
  	根据指定参数创建对象。
2. T newInstance()
  	空参构造方法创建对象。
```

#### 获取无参数构造方法

```java
public static void main(String[] args)throws Exception{
    Class cla = Class.forName("com.doit.communication.Student");
    //获取无参数构造方法
    Constructor constructor = cla.getConstructor();
    //运行构造方法
    Object object =  constructor.newInstance();
    System.out.println(object);
}
```

#### 获取有参数构造方法

```java
public static void main(String[] args)throws Throwable{
    Class cla = Class.forName("com.doit.communication.Student");
    //获取有参数构造方法
    Constructor constructor = cla.getConstructor(String.class, int.class);
    //运行构造方法，传递实际参数
    Object object = constructor.newInstance("张三",20);
    System.out.println(object);

}
```

### 18.2.4 反射获取构造方法的简单方式
Class类中定义了方法 `T newInstance()`，可以直接运行获取到的构造方法。

**要求**：被反射的类中必须有public权限的无参数构造方法。

```java
public static void main(String[] args)throws Throwable{
    Class cla = Class.forName("com.doit.communication.Student");
    Object object = cla.newInstance();
    System.out.println(object);
}
```

### 18.2.5 反射成员方法执行
#### Class类中与Method相关方法

```java
1. Method[] getMethods()
  	获取所有的public修饰的成员方法，包括父类中。

2. Method getMethod("方法名", 方法的参数类型... 类型) 
	根据方法名和参数类型获得一个方法对象，只能是获取public修饰的	
```

#### Method类中常用方法

```java
Object invoke(Object obj, Object... args) 
    返回值Object，表示调用方法后，该方法的返回值
  	根据参数args调用对象obj的该成员方法	
  	如果obj=null，则表示该方法是静态方法
```

#### 反射获取无参数方法

```java
public static void main(String[] args)throws Throwable{
    Class cla = Class.forName("com.doit.communication.Student");
    Object object = cla.newInstance();
    //获取study方法
    Method method = cla.getMethod("study");
    //执行方法，传递对象
    method.invoke(object);
}
```

#### 反射获取有参数方法

```java
public static void main(String[] args)throws Throwable{
    Class cla = Class.forName("com.doit.communication.Student");
    Object object = cla.newInstance();
    //获取有参数的方法eat
    Method method = cla.getMethod("eat",String.class,double.class);
    //调用eat方法，传递实际参数
    method.invoke(object,"吃饭",9.9);
}
```

# 19 JDBC
JDBC（Java DataBase Connectivity）是Java和数据库之间的一个桥梁，是一个规范而不是一个实现，能够执行SQL语句。它由一组用Java语言编写的类和接口组成。

## 19.1 JDBC编程步骤
1.装载相应的数据库的JDBC驱动并进行初始化
2.建立JDBC和数据库之间的Connection连接
3.创建Statement或者PreparedStatement接口，执行SQL语句
4.处理和显示结果
5.释放资源

### 19.1.1 加载数据库驱动
前提：已导入专用的jar包。
- 初始化驱动
通过初始化驱动类com.mysql.jdbc.Driver，该类就在 mysql-connector-java-5.0.8-bin.jar中。如果你使用的是oracle数据库那么该驱动类将不同。

注意：Class.forName需要捕获ClassNotFoundException.
```java
try {
        Class.forName("com.mysql.jdbc.Driver");		
        } catch (ClassNotFoundException e) { 				
            e.printStackTrace();
        }
```
Class.forName是把这个类加载到JVM中，加载的时候，就会执行其中的静态初始化块，完成驱动的初始化的相关工作。 

### 19.1.2 建立JDBC和数据库之间的Connection连接
这里需要提供:数据库服务端的IP地址:127.0.0.1 
             数据库的端口号： 3306 （mysql专用端口号）
             数据库名称 exam（根据你自己数据库中的名称填写）
             编码方式 UTF-8
             账号 root
             密码 admin
```java
Connection c = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/exam?characterEncoding=UTF-8", "root", "admin");

//或

String url = "jdbc:mysql://localhost:3306/shen";
String username = "shen";
String password = "Anxin062039";
Connection conn = null;

conn = DriverManager.getConnection(url, username, password);
```

- Connection
Jdbc程序中的Connection，它用于代表数据库的链接，Collection是数据库编程中最重要的一个对象，客户端与数据库所有交互都是通过connection对象完成的，创建方法为：

Connection conn = DriverManager.getConnection(url,user,pass); 

这个对象的常用方法：
createStatement()————创建向数据库发送sql的statement对象。
prepareStatement(sql)————创建向数据库发送预编译sql的PrepareSatement对象。
prepareCall(sql)————创建执行存储过程的callableStatement对象。
setAutoCommit(boolean autoCommit)————设置事务是否自动提交。
commit()————在链接上提交事务。
rollback()————在此链接上回滚事务。


- Connection是与特定数据库连接回话的接口，使用的时候需要导包，而且必须在程序结束的时候将其关闭。getConnection方法也需要捕获SQLException异常。

- 因为在进行数据库的增删改查的时候都需要与数据库建立连接，所以可以在项目中将建立连接写成一个工具方法，用的时候直接调用即可：
```java
        /**
	 * 取得数据库的连接
	 * @return 一个数据库的连接
	 */
public static Connection getConnection(){
		Connection conn = null;
		 try {
			 	//初始化驱动类com.mysql.jdbc.Driver
	            Class.forName("com.mysql.jdbc.Driver");
	            conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/exam?characterEncoding=UTF-8","root", "admin");
	            //该类就在 mysql-connector-java-5.0.8-bin.jar中,如果忘记了第一个步骤的导包，就会抛出ClassNotFoundException
	        } catch (ClassNotFoundException e) { 				
	            e.printStackTrace();
	        }catch (SQLException e) {							
	            e.printStackTrace();
	        }
		 return conn;
	}
```

### 19.1.3 创建Statement或者PreparedStatement接口，执行SQL语句
#### 使用Statement接口
Statement接口创建之后，可以执行SQL语句，完成对数据库的增删改查。其中 ，增删改只需要改变SQL语句的内容就能完成，然而查询略显复杂。在Statement中使用字符串拼接的方式，该方式存在句法复杂，容易犯错等缺点，具体在下文中的对比中介绍。所以Statement在实际过程中使用的非常的少，所以具体的放到PreparedStatement那里给出详细代码。

Jdbc程序中的Statement对象用于向数据库发送SQL语句，创建方法为：
```java
Statement s = conn.createStatement();
```
 Statement对象常用方法：
executeQuery(String sql)————用于向数据发送查询语句。
executeUpdate(String sql)————用于向数据库发送insert、update或delete语句
execute(String sql)————用于向数据库发送任意sql语句
addBatch(String sql)————把多条sql语句放到一个批处理中。
executeBatch()————向数据库发送一批sql语句执行。

字符串拼接方式的SQL语句是非常繁琐的，中间有很多的单引号和双引号的混用，极易出错。
```java
Statement s = conn.createStatement();
// 准备sql语句
// 注意： 字符串要用单引号'
String sql = "insert into t_courses values(null,"+"'数学')";
//在statement中使用字符串拼接的方式，这种方式存在诸多问题
s.execute(sql);
System.out.println("执行插入语句成功");
```

#### 使用PreparedStatement接口
与 Statement一样，PreparedStatement也是用来执行sql语句的与创建Statement不同的是，需要根据sql语句创建PreparedStatement。除此之外，还能够通过设置参数，指定相应的值，而不是Statement那样使用字符串拼接。
```java
        /**
	 * 修改课程
	 * @param courseId
	 * @param courseName
	 */
	public void modifyCourse(int courseId,String courseName){
		String sql = "update t_course set course_name =? where course_id=?";
		Connection conn = null;
		PreparedStatement pstmt = null;
		try {
			conn = DbUtil.getConnection();
			pstmt = (PreparedStatement) conn.prepareStatement(sql);
			pstmt.setString(1, courseName);  //利用Preparedstatement的set方法给占位符赋值
			pstmt.setInt(2, courseId);
			pstmt.executeUpdate();
		} catch (SQLException e) {
			// TODO: handle exception
			e.printStackTrace();
		}finally{
			DbUtil.close(pstmt);
			DbUtil.close(conn);		//必须关闭
		}
	}
```

#### 比较Statement和PreparedStatement
- PreperedStatement可以避免SQL注入的问题。
- Statement会使数据库频繁编译SQL，可能造成数据库缓冲区溢出。PreparedStatement 可对SQL进行预编译，从而提高数据库的执行效率。
- PreperedStatement对于sql中的参数，允许使用占位符的形式进行替换，简化sql语句的编写。

## 19.1.4 处理和显示结果
 Jdbc程序中的ResultSet用于代表Sql语句的执行结果。Resultset封装执行结果时，采用的类似于表格的方式，ResultSet对象维护了一个指向表格数据行的游标，初始的时候，游标在第一行之前，调用ResultSet.next()方法，可以使游标指向具体的数据行，进行调用方法获取该行的数据。
 
#### 获取行
- ResultSet提供了对结果集进行滚动的方法：
    - next()：移动到下一行
    - Previous()：移动到前一行
    - absolute(int row)：移动到指定行
    - beforeFirst()：移动resultSet的最前面。
    - afterLast() ：移动到resultSet的最后面。
#### 获取值
- ResultSet既然用于封装执行结果的，所以该对象提供的都是用于获取数据的get方法：
    - 获取任意类型的数据
    - getObject(int index)
    - getObject(string columnName)

- 获取指定类型的数据，例如：
    - getString(int index)
    - getString(String columnName)


执行查询语句，并把结果集返回给集合ResultSet.
```java
ResultSet rs = s.executeQuery(sql);
```
结果遍历
```java
//循环取出(id)
while(rs.next())
{
	String id=rs.getString(1);//1代表数据库中表的列数，id在第一列也可以("id")！！！
	System.out.println(id+" ");
}
```

### 19.1.5 释放资源
Jdbc程序运行完后，切记要释放程序在运行过程中，创建的那些与数据库进行交互的对象，这些对象通常是ResultSet, Statement和Connection对象。关闭的过程中遵循从里到外的原则。为了使代码简单，增加其复用性，可将这些关闭的操作写成一个方法和建立连接的方法一起放到一份工具类中。
```java
/**
	 * 封装三个关闭方法
	 * @param pstmt
	 */
	public static void close(PreparedStatement pstmt){
		if(pstmt != null){						//避免出现空指针异常
			try{
				pstmt.close();
			}catch(SQLException e){
				e.printStackTrace();
			}
			
		}
	}
	
	public static void close(Connection conn){
		if(conn != null){
			try {
				conn.close();
			} catch (SQLException e) {
				// TODO: handle exception
				e.printStackTrace();
			}
		}
	}
	
	public static void close(ResultSet rs){
		if (rs != null) {
			try {
				rs.close();
			} catch (SQLException e) {
				// TODO: handle exception
				e.printStackTrace();
			}
		}
	}
```
